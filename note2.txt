자료 구조를 알아야 하는 이유?

    Python에서 이미 제공하는 기본적인 데이터 타입으로 
    해결하기 어렵거나 효율적으로 해결이 필요한 경우.

파이썬 range 함수

    range(start,stop,step)

    연속된 숫자(정수)를 만들어주는 함수이다.
    간단히 정수 범위 표현 가능. for문 과 주로 같이 사용
    range(n)은 0,1,2,3,4,... n-1 의 숫자를 생성한다.
    마지막 숫자 n는 포함되지 않는다.
    인자가 2개일 경우 첫번째 인자는 시작하는 숫자가 된다.
    인자가 3개일 경우 마지막 인자는 숫자의 간격을 나타낸다.
    
    * 마지막 인자 step으로 음수를 지정할 수도 있다.

        range(20,0,-2)
        20, 18, 16, 14, 12, 10, 8, 6, 4, 2

    * range() 함수의 결과는 반복가능(iterable)하기 때문에 for문을 사용해 출력할 수 있다.

        haystack = [k for k in range(n)]

    Python 2에서는 range 함수의 리턴값의 자료형이 리스트였습니다.
    하지만 Python 3에서는 range 함수의 리턴값의 자료형은 'range'입니다. (클래스 range로부터 객체 range 리턴)
    Python 3에서도 range 함수를 써서 리스트를 만들고 싶으면 형 변환을 사용하면 됩니다.

    개인적인 이해

        -레인지 객체를 리턴하지만, for문을 사용해 반복이 가능한 결과를 반환.

print("%.2f" % total) ?

    print는 %를 특수 문자로 취급한다.
    f를 입력하면 인쇄 될 숫자 결과가 부동 소수점 유형이 된다.
    .2 는 포인트 뒤에 첫 2자리만 나타내도록 지시한다.

    % f 문자열 형식은 몇 자릿수의 소수점을 표시한다.
    
    % f 문자열 형식 옵션은 값을 소수점으로 처리하고 
    소수점 여섯 자리까지 출력합니다.

C언어 출력타입 %d, %f, %e, %o, %x, %u, %g ......

    %d: 10진수(정수형)

    %f: 실수형

    %e: 지수형

    %o: 8진수

    %x: 16진수

    %u: 부호없는 10진수

    %g: 실수형 자동출력

    %p: 포인터의 주소

    %c: 하나의 문자로 출력

    %s: 문자열

영어단어

    elapse - 경과하다.
    elastic - 탄력있는

for문 과 range 활용

    haystack = [k for k in range(10)] 

time 모듈

    운영 체제가 제공하는 다양한 시간 기능을 다루는 내장 모듈이다.
    운영 체제마다 시간을 다루는 방식이 다르기 때문에 이 모듈의 함수들은
    어떤 운영 체제에서 실행하느냐에 따라 결과가 다르다.
    다양한 기능을 제공하지만 실제로 자주 사용되는 기능은 time.time() 함수다.

    time.time() 함수는 컴퓨터의 현재 시각을 구하는 함수이다.

datetime 모듈

    datetime 모듈은 시간을 날짜와 시각으로 표현하는 방법을 제공해, 
    시간을 좀더 인간의 관점에 가깝게 다루도록 해준다.

    datetime 모듈은 시간을 다루기 위한 여러 가지 클래스를 제공한다. 
    
        날짜를 다루는 datetime.date 클래스 
        시각을 다루는 datetime.time 클래스
        일시를 다루는 datetime.datetime 클래스.

max()

    max(iterable)는 인수로 반복 가능한 자료형을 입력받아 
    그 최대값을 리턴하는 함수이다.

    * 리스트가 아닌 자료구조를 만들어서 사용하면
      크기가 큰 리스트에서 max를 이용하여 시퀀스를
      하나하나 보는 것보다 최대값을 훨씬 효율적으로 찾을 수 있다.

------------------------------------------------------

자료구조를 이해해야 하는 이유?

* 해결하고자 하는 문제에 따라 (응용 종류와 범위에 따라) 최적의 해법은 서로 다르다.
    
    -> 이 선택을 어떻게 해야 하느냐를 알기 위해 자료구조를 이해해야 한다.

알고리즘 (algorithm) 이란?

    사전적 정의 - 어떤 문제를 해결하기 위한 절차, 방법, 명령어의 집합

    프로그래밍 - 주어진 문제의 해결을 위한 자료구조와 연산 방법에 대한 선택

-----------------------------------------------------

선형 배열 (Linear Arrays)

    선형 배열은 데이터들이 선 (line) 처럼 일렬로 늘어선 형태를 말합니다. 

    Python 에서는 서로 다른 종류의 데이터, 
    줄세울 수 있는 리스트 (list) 라는 데이터형이 있습니다.
    (다른 언어보다 좀더 융통성 있다고 한다.)

    어떠한 언어는 array는 동일한 종류의 원소들만이 줄을 설 수 있지만,
    리스트는 아무런 데이터 타입이라도 원소로 줄을 세울 수 있다.
    서로 다른 데이터 타입들도 리스트 안에 넣을 수 있다.

    * 파이썬에서 인덱스에 -2 를 적으면 뒤에서부터 두번째 자료에 접근 가능.

    배열과 리스트는 우선 같은 것이라고 생각해도 좋지만, 
    개념적인 구조, 즉 데이터를 늘어놓은 모양새를 말할 때는 배열 (array), 
    Python 의 데이터형을 가리킬 때에는 리스트 (list) 라는 용어를 사용하도록 하자.

--------------------------------------------------------
Python 리스트에 활용할 수 있는 연산들 --------------------

* 리스트 길이과 관계 없이 빠르게 실행 결과를 보게되는 연산들

    원소 덧붙이기 .append()
    원소 하나를 꺼내기 .pop()
    
    위 연산들은 리스트의 길이와 무관하게 빠르게 실행할 수 있는 연산이다. 
    리스트의 길이가 아무리 길어도 맨 끝에 요소 하나를 추가하는 것이나 
    맨 끝 요소 하나를 빼는건 빠르게 할 수 있는 일이다. 
    반면, 리스트가 커지면 그에 따라 실행시간이 길어지는 연산들도 있다.

    Big O Notation 으로 상수 시간에 해당한다.

        - 순식간에 빠르게 할 수 있는 일, 리스트의 길이와 무관하므로 상수 시간.

* 리스트의 길이에 비례해서 실행 시간이 걸리는 연산들

    원소 삽입하기 .insert()

        ex)
            L = [20, 37, 58, 72, 91]
            L.insert(3, 65)

            4번째 원소로 65가 추가된다.

    원소 삭제하기 .del()

        ex)
            L = [20, 37, 58, 65, 72, 91]
            del(L[2])

            세번째 원소가 삭제된다.

            del(L[2])은 삭제만 하지만
            L.pop(2)는 원소를 리턴하며 그 원소를 리스트에서 삭제시킨다.
          
    이런 연산들은 리스트의 길이가 길면 길수록 처리가 오래 걸린다. 
    구체적으로 말하면 리스트의 길이예 실행 시간이 비례한다. 
    리스트 길이가 100 배가 되면, 위 연산들을 실행하는 데 걸리는 시간도 100 배 커진다.

추가 다른 연산

    원소 탐색하기: .index()

리스트의 길이가 길면 오래 걸리는 일

    -> 리스트의 길이에 비례한다. (선형 시간)

    Big O Notation으로 O(n)이다.




