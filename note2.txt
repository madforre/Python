자료 구조를 알아야 하는 이유?

    Python에서 이미 제공하는 기본적인 데이터 타입으로 
    해결하기 어렵거나 효율적으로 해결이 필요한 경우.

파이썬 range 함수

    range(start,stop,step)

    연속된 숫자(정수)를 만들어주는 함수이다.
    간단히 정수 범위 표현 가능. for문 과 주로 같이 사용
    range(n)은 0,1,2,3,4,... n-1 의 숫자를 생성한다.
    마지막 숫자 n는 포함되지 않는다.
    인자가 2개일 경우 첫번째 인자는 시작하는 숫자가 된다.
    인자가 3개일 경우 마지막 인자는 숫자의 간격을 나타낸다.
    
    * 마지막 인자 step으로 음수를 지정할 수도 있다.

        range(20,0,-2)
        20, 18, 16, 14, 12, 10, 8, 6, 4, 2

    * range() 함수의 결과는 반복가능(iterable)하기 때문에 for문을 사용해 출력할 수 있다.

        haystack = [k for k in range(n)]

    Python 2에서는 range 함수의 리턴값의 자료형이 리스트였습니다.
    하지만 Python 3에서는 range 함수의 리턴값의 자료형은 'range'입니다. (클래스 range로부터 객체 range 리턴)
    Python 3에서도 range 함수를 써서 리스트를 만들고 싶으면 형 변환을 사용하면 됩니다.

    개인적인 이해

        -레인지 객체를 리턴하지만, for문을 사용해 반복이 가능한 결과를 반환.

print("%.2f" % total) ?

    print는 %를 특수 문자로 취급한다.
    f를 입력하면 인쇄 될 숫자 결과가 부동 소수점 유형이 된다.
    .2 는 포인트 뒤에 첫 2자리만 나타내도록 지시한다.

    % f 문자열 형식은 몇 자릿수의 소수점을 표시한다.
    
    % f 문자열 형식 옵션은 값을 소수점으로 처리하고 
    소수점 여섯 자리까지 출력합니다.

C언어 출력타입 %d, %f, %e, %o, %x, %u, %g ......

    %d: 10진수(정수형)

    %f: 실수형

    %e: 지수형

    %o: 8진수

    %x: 16진수

    %u: 부호없는 10진수

    %g: 실수형 자동출력

    %p: 포인터의 주소

    %c: 하나의 문자로 출력

    %s: 문자열

영어단어

    elapse - 경과하다.
    elastic - 탄력있는

for문 과 range 활용

    haystack = [k for k in range(10)] 

time 모듈

    운영 체제가 제공하는 다양한 시간 기능을 다루는 내장 모듈이다.
    운영 체제마다 시간을 다루는 방식이 다르기 때문에 이 모듈의 함수들은
    어떤 운영 체제에서 실행하느냐에 따라 결과가 다르다.
    다양한 기능을 제공하지만 실제로 자주 사용되는 기능은 time.time() 함수다.

    time.time() 함수는 컴퓨터의 현재 시각을 구하는 함수이다.

datetime 모듈

    datetime 모듈은 시간을 날짜와 시각으로 표현하는 방법을 제공해, 
    시간을 좀더 인간의 관점에 가깝게 다루도록 해준다.

    datetime 모듈은 시간을 다루기 위한 여러 가지 클래스를 제공한다. 
    
        날짜를 다루는 datetime.date 클래스 
        시각을 다루는 datetime.time 클래스
        일시를 다루는 datetime.datetime 클래스.

max()

    max(iterable)는 인수로 반복 가능한 자료형을 입력받아 
    그 최대값을 리턴하는 함수이다.

    * 리스트가 아닌 자료구조를 만들어서 사용하면
      크기가 큰 리스트에서 max를 이용하여 시퀀스를
      하나하나 보는 것보다 최대값을 훨씬 효율적으로 찾을 수 있다.

------------------------------------------------------

자료구조를 이해해야 하는 이유?

* 해결하고자 하는 문제에 따라 (응용 종류와 범위에 따라) 최적의 해법은 서로 다르다.
    
    -> 이 선택을 어떻게 해야 하느냐를 알기 위해 자료구조를 이해해야 한다.

알고리즘 (algorithm) 이란?

    사전적 정의 - 어떤 문제를 해결하기 위한 절차, 방법, 명령어의 집합

    프로그래밍 - 주어진 문제의 해결을 위한 자료구조와 연산 방법에 대한 선택

-----------------------------------------------------

선형 배열 (Linear Arrays)

    선형 배열은 데이터들이 선 (line) 처럼 일렬로 늘어선 형태를 말합니다. 

    Python 에서는 서로 다른 종류의 데이터, 
    줄세울 수 있는 리스트 (list) 라는 데이터형이 있습니다.
    (다른 언어보다 좀더 융통성 있다고 한다.)

    어떠한 언어는 array는 동일한 종류의 원소들만이 줄을 설 수 있지만,
    리스트는 아무런 데이터 타입이라도 원소로 줄을 세울 수 있다.
    서로 다른 데이터 타입들도 리스트 안에 넣을 수 있다.

    * 파이썬에서 인덱스에 -2 를 적으면 뒤에서부터 두번째 자료에 접근 가능.

    배열과 리스트는 우선 같은 것이라고 생각해도 좋지만, 
    개념적인 구조, 즉 데이터를 늘어놓은 모양새를 말할 때는 배열 (array), 
    Python 의 데이터형을 가리킬 때에는 리스트 (list) 라는 용어를 사용하도록 하자.

--------------------------------------------------------
Python 리스트에 활용할 수 있는 연산들 --------------------

* 리스트 길이과 관계 없이 빠르게 실행 결과를 보게되는 연산들

    원소 덧붙이기 .append()
    원소 하나를 꺼내기 .pop()
    
    위 연산들은 리스트의 길이와 무관하게 빠르게 실행할 수 있는 연산이다. 
    리스트의 길이가 아무리 길어도 맨 끝에 요소 하나를 추가하는 것이나 
    맨 끝 요소 하나를 빼는건 빠르게 할 수 있는 일이다. 
    반면, 리스트가 커지면 그에 따라 실행시간이 길어지는 연산들도 있다.

    Big O Notation 으로 상수 시간에 해당한다.

        - 순식간에 빠르게 할 수 있는 일, 리스트의 길이와 무관하므로 상수 시간.

* 리스트의 길이에 비례해서 실행 시간이 걸리는 연산들

    원소 삽입하기 .insert()

        ex)
            L = [20, 37, 58, 72, 91]
            L.insert(3, 65)

            4번째 원소로 65가 추가된다.

    원소 삭제하기 .del()

        ex)
            L = [20, 37, 58, 65, 72, 91]
            del(L[2])

            세번째 원소가 삭제된다.

            del(L[2])은 삭제만 하지만
            L.pop(2)는 원소를 리턴하며 그 원소를 리스트에서 삭제시킨다.
          
    이런 연산들은 리스트의 길이가 길면 길수록 처리가 오래 걸린다. 
    구체적으로 말하면 리스트의 길이예 실행 시간이 비례한다. 
    리스트 길이가 100 배가 되면, 위 연산들을 실행하는 데 걸리는 시간도 100 배 커진다.

추가 다른 연산

    원소 탐색하기: .index()

리스트의 길이가 길면 오래 걸리는 일

    -> 리스트의 길이에 비례한다. (선형 시간)

    Big O Notation으로 O(n)이다.

--------------------------------

Python 리스트 정렬

    1. sorted()

        파이썬의 내장함수. 정렬된 리스트를 얻어낸다.

    2. .sort()

        리스트의 메서드. 해당 리스트를 정렬한다.

정렬의 순서를 반대로?

    reverse=True 인자를 추가하면 된다.

    ex) L2 = sorted(L, reverse=True)
        L.sort(reverse=True)

문자열로 이루어진 리스트의 경우?

    정렬 순서는 사전 순서(알파벳 순서)를 따른다.
    대문자는 소문자보다 우선한다.
    (문자열 길이가 긴 것이 더 큰 것이 아니다.)

문자열 길이 순서로 정렬하려면?

    정렬에 이용하는 키(key) 지정

        파이썬에서는 함수에서 return 한 값을 함수로 쓰고 싶다면 lambda 를 쓰는게 좋다.
        함수를 값처럼 다른 함수로 전달해준다.

        key파라미터에는 함수가 와야 한다. 

        key 파라미터에 함수가 설정되면 소트해야 할 리스트들의 항목들이 하나씩 key 함수에 
        전달되어 key 함수가 실행되게 된다. 이 때 수행된 key 함수의 리턴값을 기준으로 
        소트가 진행된다.

        * 람다는 함수를 다른 함수의 인수로 넣을 때 매우 편리하다.
          함수를 값처럼 다른 함수로 전달해준다.

    정렬 - 키를 지정하는 예

        L.sort(key=lambda x:x['name'])

        -> 레코드들을 이름 순서대로 정렬

        operator 모듈 사용하는 방법도 있다.

            operator모듈의 itemgetter와 attrgetter를 이용하면 좀 더 간략하게 작성 가능

---------------------------------

탐색 알고리즘

    선형 탐색(Linear Search)

        앞에서 부터 뒤로 하나하나씩 순차적으로 비교해나가면서 찾는 방법

        리스트의 길이에 비례하는 시간 소요
            -> O(n)
        
        최악의 경우 : 모든 원소를 다 비교해 보아야 한다.
        
        * 빅오표기법은 최악의 경우 걸리는 시간과 관련하여 표기한 것

    이진 탐색(Binary Search)

        탐색하려는 리스트가 이미 정렬되어 있는 경우에만 적용 가능

        * 크기 순으로 정렬되어 있다는 성질 이용!

        한 번 비교가 일어날 때마다 리스트를 반씩 줄임!
        컴퓨터 공학에서는 divide & conquer 라고 한다.

        알고리즘의 복잡도는 Big O Notation 으로 O(log n)

    * 이진 탐색이 선형 탐색보다 빠른 방법이다. 그러나, 뭔가를 찾으려 한다고 할 때, 
      항상 이진 탐색 방법을 적용하는 것이 답인가? 그러려면 우선 배열을 정렬해야 하는데, 
      크기 순으로 정렬하는 것은 금방 되는 것은 아니다. 
      한 번만 탐색하고 말 거라면, 굳이 크기 순으로 늘어놓느라 시간을 소모하는 것보다 
      한번씩 다 뒤지는 것이 물론 낫다.

-----------------------------------------------------------------------------------

python 에서는 자동으로 소수점을 제거 하는 다음의 2가지 경우가 있는데 각각 동작 방식이 다르다.

    int() - 버림

        >>> int(1.1)
        1
        >>> int(1.9)
        1
        >>> int(-1.1)
        -1
        >>> int(-1.9)
        -1
    
    // 연산 - 내림

        >>> 11 // 10
        1
        >>> 19 // 10
        1
        >>> -11 // 10
        -2
        >>> -19 // 10
        -2

    내림과 버림을 혼동하지 말자!        

------------------------------------------------------------------------------------

파이썬 in 연산자의 시간복잡도

list, tuple

    Average : O(n) - 하나하나 순회하기 때문에 데이터의 크기만큼 시간 복잡도를 갖게 됩니다.

set, dictionary

    Average : O(1), Worst : O(n)

    내부적으로 hash를 통해서 자료들을 저장하기 때문에 시간복잡도가 O(1)가 가능하고 
    O(n)의 경우에는 해시가 성능이 떨어졌을(충돌이 많은 경우) 때 발생합니다.

--------------------------------------------------------------------------------------

재귀 알고리즘 (Recursive Algorithms)

    하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 것

        - 생각보다 많은 종류의 문제가 재귀적으로(recursively) 해결이 가능하다.
    
    예 ) 이진 트리 (이진 탐색과 비슷한 방법으로 트리 형식을 탐색)

    간단한 예

        - 1부터 n 까지의 자연수의 합을 구하라

            sum = 1 + 2 + ... + n
            sum = {1 + 2 + ... + (n-1)} + 1

            def sum(n) : 
                if n <=1:
                    return n
                else:
                    return n + sum(n-1) 

    * 재귀 함수를 호출할 때는 종결 조건이 매우 중요하다!

    Recursive version에는 그에 대응하는 시간 복잡도가 같은 Iterative version이 있다.
    
    재귀적인 방법이 꼭 좋은 것은 아니다.
    효율적인 측면에서 재귀를 사용하지 않더라도 더 좋은 코드를 구현할 수도 있다.

-------------------------------

해싱이란?

해싱(Hashing)은 하나의 문자열을 원래의 것을 상징하는 더 짧은 길이의 값이나 키로 변환하는 것이다. 

* 짧은 해시 키를 사용하여 항목을 찾으면 원래의 값을 이용하여 찾는 것보다 더 빠르기 때문에, 
  해싱은 데이터베이스 내의 항목들을 색인하고 검색하는데 사용된다.

-------------------------------

순열 Permutation

n개 중에서 r개를 뽑아 순서대로 나열한 경우의 수

--------------------------------

조합 Combination

n 개 중에서 r개를 뽑는 경우의 수
n 개의 서로 다른 원소에서 m 개를 택하는 경우의 수

재귀적 방법(파스칼 삼각형 이용 nCm)

n       n-1     n-1
    =        +
m       m       m-1


----------------------------------

재귀 알고리즘 - 이해하기 쉽게 서술할 수 있는 서술적인 장점, 문제를 풀어내는 시간적인 단점.

    하나의 재귀 알고리즘이 주어질 때, 이것을 재귀적이지 않은 (non-recursive) 방법으로 
    동일하게 풀어내는 알고리즘이 존재한다는 것을 수학적으로 증명할 수 있습니다. 
    보통은 순환문 (loop) 을 이용해서 정해진 연산을 반복함으로써 문제의 답을 구하는데, 
    따라서 반복적 (iterative) 알고리즘이라고 부르기도 합니다. 

* 일반적으로, 주어진 문제에 대해서 반복적인 알고리즘이 재귀적인 알고리즘보다 문제 풀이의 (시간적) 효율이 높습니다.

---------------------------------

알고리즘의 복잡도 (Complexity of Algorithms)

    알고리즘의 복잡도 (complexity) 라고 부르는 것은 문제 풀이의 방식이 
    얼마나 복잡하냐 단순하냐를 나타내는 말이 아닙니다.
    알고리즘이 실행함에 있어, 문제의 크기 (일반적으로 데이터 원소의 개수를 뜻합니다) 가 커짐에 따라서 
    얼마나 큰 시간을 (또는 공간을) 요구하느냐를 뜻합니다.

* 알고리즘의 복잡도는 알고리즘을 실행함에 있어 얼마나 큰 시간 또는 공간을 요구하느냐를 뜻한다.

시간 복잡도 (Time Complexity)

    - 문제의 크기와 이를 해결하는 데 걸리는 시간 사이의 관계

공간 복잡도 (Space Complexity)

    - 문제의 크기와 이를 해결하는 데 필요한 메모리 공간 사이의 관계

----------------------------------

평균 시간 복잡도 (Average Time Complexity)

    - 임의의 입력 패턴을 가정했을 때 소요되는 시간의 평균

최악 시간 복잡도 (Worst-case Time Complexity)

    - 가장 긴 시간을 소요하게 만드는 입력에 따라 소요되는 시간

Big-O Notation

    - 점근 표기법 (asymptotic notation) 의 하나

    - 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현
      (알고리즘의 복잡도를 표현할 때 흔히 쓰임)

      O(logn), O(n), O(n²), O(2ⁿ) 등으로 표기.

      O of n 이런식으로 읽는다. 
      O of n square 
      2의 n승- O of two to the power of n

    - 상수는 중요하지 않음

선형 시간 알고리즘 - O(n)

    예 - n 개의 무작위로 나열된 수에서 최댓값을 찾기 위해 선형 탐색
        알고리즘을 적용

        Average case: O(n)
        Worst-case: O(n)

로그 시간 알고리즘 - O(logn)

    예 - n 개의 크기 순으로 정렬된 수에서 특정 값을 찾기 위해 
        이진 탐색 알고리즘을 적용

    * 굉장히 효율이 좋은 알고리즘이다.

이차 시간 알고리즘 - O(n²)

    예 - 삽입 정렬 (insertion sort)

    하나의 원소를 집어넣을 때 n에 비례하는 만큼의 횟수를 비교하여 삽입할 위치를 정하고,
    그 동작을 원소의 갯수인 n 만큼 반복하니까 n x n 즉 O(n²) 의 복잡도를 가진다.

    Best case: O(n) - 이미 정렬이 되어있는 경우. n개를 살펴보기만 하고 끝난다.
    Worst case: O(n²) - 역순으로 정렬된 경우.

보다 나은 (낮은) 복잡도를 가지는 정렬 알고리즘

    예 - 병합 정렬 (merge sort) - O(nlogn)

    참고 : 입력 패턴에 따라 정렬 속도에 차이가 있지만 
            정렬 문제에 대해 O(nlogn) 보다 낮은 복잡도를 갖는
            알고리즘은 존재할 수 없음이 이미 수학적으로 증명되어 있다.

    정렬한 데이터를 반씩 나누어 각각을 정렬시킨다. (divide and conquer) logn
    정렬된 데이터를 두 묶음씩 한데 합친다. O(n)

* 병합 정렬은 log n * n -> O(logn) 만큼의 시간 복잡도를 가지는 정렬 알고리즘이다.

꽤나 복잡한 문제

    유명한 예 - 배낭 문제 (Knapsack Problem)

    앞에서 살펴본 것보다 좀 더 복잡한 문제이다. 
    동적 프로그래밍을 통해서 해결할 수도 있다.
