소켓 - 통신

    프로그램마다 소켓이 들어있음.

    소켓은 다른 소켓과 서로 데이터를 주고받을 수 있다.

    즉 프로그램들끼리 통신이 가능함.

    가장 큰 특징은, 다른 컴퓨터와 네트워크가 쭉쭉 연결되어있으면
    다른 컴퓨터에서 실행한 프로그램의 소켓과도 통신이 가능하게 해준다는 것.

    소켓은 유닉스,리눅스 기준에서 파일 그 자체이다.
    파일을 생성해서 필요한 정보를 저장해놓고 사용한다.

    ls -al 치면 d가 디렉토리 s가 소켓을 뜻함.

    소켓은 주소정보를 담고 있다.
    한 컴퓨터 내에서 현재 돌고 있는 프로세스를 구분해준다.

    * 소켓으로 통신을 하려면 어떤 프로세스인지 알고 찾아가야 한다.

        그걸 알려주는 것이 포트번호.

        또 필요한 것은 ip주소.

        즉 소켓은 ip주소와 포트번호, 이 두가지 정보를 가지고 있다.

    데이터를 담아서 어디든 보낼 수 있음.

TCP / UDP 프로토콜

    TCP - 연결형 통신 ( 소켓끼리 연결을 하고, 한번 연결하면 연결한 상태를 유지한다. )

        중간에 데이터가 빠진 부분이 있으면 빠진걸 다시 보내줌. 즉 신뢰성 있는 프로토콜이다.
        가장 낮은 계층에서 네트워크를 ㅈ가동시킨다.

        three way handshake 간다?->응 와->감

            * 중요한 파일전송 (중간에 하나라도 빠지면 안되는 것들 전송할 때 쓰인다.)에 쓰인다.

    UDP - 비연결형 통신 ( 소켓이 있으면 데이터를 한번보낸다. 그러면 끝. 잘못받았는지 받았는지는 관심 없음.)

        장점은 속도가 빠르다. 하지만 잘 받았는지 안받았는지 신경 안쓴다.
        데이터를 담아서 그냥 보내면 끝이다.

            * 스트리밍 , 전화에 쓰인다. ( 데이터가 중간에 유실되더라도 큰 지장이 없음. )


socket 메소드 안의 메소드들 connect, send, recv 등을 사용하여 소켓 통신하도록 프로그래밍.

connect는 클라이언트. 서버에서는 소켓을 만들어서 accept를 해야함

사용하려면 import socket해주자. 기본 모듈임.


서버 측

    bind -> listen -> accept

클라이언트 측



패킷?

    패킷(packet)은 사전적인 의미로는 '한 다발, 한 묶음'을 뜻하는 말로 통신, 네트워크에서는 한 번에 전송하는 정보의 단위를 일컫습니다.

쓰래드

    하나의 프로세스에서 두가지 작업을 동시에 하는 것이다. 여러개의 처리를 해주는 것이다.


함수 정의

    def 로 정의하도록 한다.

---------------------------------------------------------

라즈베리 파이 - 단일 보드 컴퓨터

CPU(Central Processing Unit) - 머리, 두뇌
      현대 CPU는 1960년대와 달리 축전기, 저항기, 트랜지스터 회로가
      극소화 되어있다. 광학적인 방법으로 더 작고 더 많이 회로를 새겨놓았음.
      몇백만 개를 한 개로 만들 수 있는 것이다.
      프로그램을 실행한다. CPU는 항상 다음에 무엇을 하지? 라고 물어본다.
      처리능력이 매우 뛰어나다.

메인 메모리 - 명령이 저장되어 있음.
             메인메모리는 CPU가 필요로하는 명령을 제공한다.
             CPU에게 명령을 전달한다.
             빠르게 작동하며 프로그램을 저장한다.
             속도는 매우 빠르지만 컴퓨터를 종료하면 사라지는 휘발성 메모리.

CPU가 새로운 명령이 필요하면 메인 메모리한테 어디에 명령이 있는지 물어본다.
소프트웨어를 통해 CPU를 제어한다.

마더보드 - 모든 부품을 연결한다. (메모리, CPU, 하드 드라이브 등등 끼워넣어서 사용한다.)
            모든 부품을 연결해줌.

보조 기억장치 - ex) 하드드라이브 SSD HDD, USB
               영구적으로 데이터를 저장한다.
               메인메모리와 다른 점?
               메인 메모리는 매우 빠르다.
               하지만 전원을 끄면 정보가 사라진다.
               워드 파일, 텍스트 파일등을 기록해 두려면 오래된 곳에 저장해서 보관해야 한다.
               보조 저장소가 그 역할을 한다. 전원이 꺼져도 영구적으로 메모리를 저장한다.

우리 프로그래머들은 메인 메모리에 서 있다.
코드를 작성하면 메인 메모리가 CPU에 전달하여 명령을 처리한다.

각각의 관계

  CPU는 계속해서 다음에 무엇을 할지 물어 봅니다.
  이것에 대한 답변은 사람이 하며, 답변들의 목록이나 순차적으로 진행되어야 할 사항들을
  파이썬 언어로 작성한 뒤 보조 기억장치에 저장합니다. CPU의 질문에 답변을 해야 하는 순간이 오면
  메인 메모리에 해당 내용을 로드 합니다. 이 과정에서 2진수로 만들어져 있는 기계어로 마법처럼
  변환이 되며 이는 컴퓨터가 이해할 수 있는 언어로 전달 되게 됩니다.
  그 후 내부적으로는 1초에 수십억번(CPU에 성능에 따라 달라집니다)에 걸쳐
  질문과 답변이 이루어 지게 됩니다.

파이썬은 Monty Python's Flying이라는 서커스에서 영감을 받아 지은 이름이다.
귀도 반 로섬이 20년전에 만듦. 강력하고 다가가기 쉬운, 재밌는 프로그래밍 언어를
만들고 싶었던 귀도 반 로섬의 마음을 잘 보여주는 네이밍이다.
배우기 쉽고 간결하고 강력하다.

------------------------------------------------

파이썬의 예약어

Reserved Words - 예약어

  일종의 약속과 같다.

  False, class, return, is, finally, None, if, for, lambda, continue
  True, def, from, while, nonlocal, and, del, global, not, with, as,
  elif, try, or, yield, assert, else, import, pass, break, excpet,
  in, raise

  예약어는 약속된 단어이기 때문에 변수의 이름이나 식별자로 사용할 수 없습니다.

Sentences or Lines - 문장/줄

  x = 2       Assignment statement 대입문
  x = x + 2   Assignment with expression ( 대입문 + 표현식 )
  print(x)    Print statement ( 출력문 )

  변수 연산자 상수 함수로 구성되어있다.

프로그래밍 문단

  Python Scripts - 스크립트

    대부분의 프로그램은 길기 떄문에 파일에 코드를 적고
    파이썬이 파일에 있는 명령을 실행한다.
    파일 이름에 .py를 붙여 파이썬을 썼다는 것을 표시
    파이썬에 스크립트를 주는 것과 같음.
    코드가 길어질 경우에는 스크립트 방식이 효과적이다.
    파일을 보조 기억장치에 저장 한 뒤 한 번에 실행시켜 처리한다.

  Interactive - 상호대화식

    파이썬에 한 줄을 입력하면 바로 반응.
    코드가 생각한 대로 작동하는지 테스트하기 좋다.
    3~4줄의 코드를 실험하기 좋음.
    커맨드라인에서 한줄씩 실행하는 방법은 상호대화식이라고 한다.
    즉각적이 ㄴ결과 호가인에 유리하다.

프로그램 단계 / 흐름

- 순차문 : 레시피나 설명문과 같이 진행 순서를 가짐. 순서대로 진행됨
          (Sequential Steps)

- 조건문 : 건너뛸 수 있음
          (Conditional Steps)

- 반복문 : 반복되어 실행
          (Repeated Steps)

* 들여쓰기가 없는 부분은 순차적으로 실행된다.

---------------------------------

Constants - 상수 (변하지 않는 고정 값)

Variables - 변수 (메모리 안의 이름이 지정된 장소에 데이터를 저장할 수 있음)
            값을 원하는대로 변경할 수 있다.

Python Variable Name Rules

  파이썬과 대화할 때 밑줄을 쓰기 떄문에 되도록 변수 이름을 밑줄로 시작하지 않습니다.
  첫 글자 다음으로 문자, 숫자, 밑줄이 올 수 있습니다.

  * 대소문자로 변수를 구별하지 말 것!!! 정말 안좋은 생각이다. 숫자로 시작해도 안좋다.
    #이나 .으로 시작해도 안좋음.
    문자로 시작하고 다음에 문자, 숫자, 밑줄 변수 이름을 정합니다.

Mnemonic Variable Names (연상기호, 기억을 돕는 변수 이름)

  변수 이름은 프로그래머 마음대로 아무 이름으로 지정해도 된다. - 단, 모범 기준을 따르자.
  변수 값과 연관 지어 변수 이름을 지정 (연상 기호)
  단점 : 변수 이름이 키워드인 것 같아 보일 수 있기 때문에 초급자는 헷갈릴 수 있음.

Sentences or Lines

  Variable / Operator / Constant / Reserved Word로 구성되어 있음.

-------------------------------------

Numeric Expressions - 숫자 표현식(연산자)

  + Addition
  - subtraction
  * Multiplication
  / Division
  ** Power
  % Remainder (It's also called the modulo operator.)

--------------------------------------

Order of Evaluation (값 구하는 순서, 연산자 순위)

  우선순위

  1. 괄호먼저. (Parenthesis)
  2. 그다음 거듭제곱이 우선 (Power)
  3. 그다음 곱하기 나누기 (Multiplication, Division)
  4. 더하기, 빼기 (Addition, Subtraction)

  계산시 Left to Right. 왼쪽에서 오른쪽 법칙 적용.

-------------------------------------

연산자는 똑똑합니다.
값 변수 상수인지에 따라 다른 연산을 합니다.

Traceback은 작동하다가 혼란스러운 부분이 있어 더이상 실행시키지 않는 것입니다.

파이썬은 타입에 민감합니다.

파이썬은 내재된 함수 type을 사용하여 타입을 확인 가능하다.

type()

--------------------------------------

int 정수

float 부동 소수점 수(파이썬에서 숫자를 표현하는 방법이다.)

상수는 int이거나 float일 수 있다.

* 내재된 함수 int나 float를 사용해서 타입을 바꿀 수도 있다.

파이썬 3에서의 정수 나눗셈은 항상 부동 소수점 수를 줍니다.
예측 가능하고, 계산기처럼 작동합니다.

* 파이썬 3.0에서 나눗셈은 부동 소수점 수를 줍니다!

---------------------------------------

고정 소수점(Fixed-point arithmetic) 형식

  이는 소수점의 위치가 특정 위치에 고정되어 있다고 가정하고 실수를 표현하는 방식입니다.
  예를 들어 1230과 1230000이라는 수가 있을 때 소수점의 위치가 1000이라고 하면
  각각의 수는 1.23과 1230을 나타내게 되는 것입니다.

부동 소수점(Floating Point) 형식

  이는 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적어내어
  실수를 표현하는 방식으로 유효숫자를 나타내는 가수부와 소수점의 위치를 나타내는
  지수부로 나누어 표현합니다. 고정 소수점 방식보다 매우 큰 수와 작은 수등
  넓은 범위의 수를 나타낼 수 있는 것이 큰 특징입니다.

  고정 소수점 표현 : 123.456
  부동 소수점 표현 : 0.123456×10³ = 가수×지수

이런게 있다는 걸로 만 알고 있자..
----------------------------------------

String Conversions(문자열 변환)

  int나 float 함수를 사용하여 타입을 바꿀 수 있다.

---------------------------------------

User Input (사용자 입력)

  input() 함수로 멈추고 사용자의 입력값을 받을 수 있음

  input() 함수는 문자열을 반환.

--------------------------------------

주석

파이썬은 # 다음 모든 내용을 무시

-------------------------------------

Indentation (들여쓰기)

  파이썬에서는 들여쓰기가 잘못되면 에러가 뜹니다.
  고로 중요하다.
  띄어쓰기 4번, 스페이스 4번이 들여쓰기 기준이다.

  파이썬은 탭과 들여쓰기를 꼭 구분해줘야 한다.
  에디터의 설정이 탭이 스페이스 4번이 아닐 경우 탭을쓰면 들여쓰기 에러가 뜬다.
  문법 에러 발생. (설정에서 탭의 기능 변경하기에서 스페이스 설정을 해주어야 한다.)

  * 들여쓰기를 통해 어디까지가 if문인지 정할 수 있다.

  블록들은 콜론을 시작으로 내어쓰기가 된 줄을 포함하지 않은 곳 까지 이어진다.

---------------------------------------

Two-way Decisions

  If와 else를 사용한 두 갈래길 조건문

------------------------------------------

들여쓰기가 복잡하다고 생각할 수 있지만, 파이썬은 우아한 언어이다.

* 조건문이 참일 경우 실행할 코드는 들여쓰기를 해야한다.
* 조건문 후에 : (콜론) 을 찍어야 한다.

------------------------------------------

Multi-way Decisions(다중 분기)

  elif라는 예약어를 이용한다.

    if, elif, else 중 하나만 실행된다.
    중요한 것은 질문을 순서에 따라 확인하는 것이다.
    * 첫 번째 질문이 거짓일 때까지 두 번째 질문을 확인하지 않는다.
    else가 없어도 된다. (아무것도 실행 안될 수 있다.)

----------------------------------------------

try / except

  파이썬은 복구하고 싶은 부분에 trackback 에러를 띄우는 경향이 있다.

  에러가 나서 프로그램이 중단될 부분을 안다면 중단되는 것을 원치 않을 것이다.
  프로그래머는 사용자의 입력 값을 보고 코드에서 중단될 수 있는 부분이 어디인지를
  예상할 수 있어야 합니다. 그리고 해결을 할 줄 알아야 합니다.
  이 때 try 와 except를 이용해서 합니다.

  * try부분을 실행하되, 실패하면 except 부분을 실행된다.
    뭔가가 잘못됐을 때 except 블록이 나서서 에러가 떴을 때 진행해야
    할 일을 합니다.

    남용하지 않도록 조심하도록 하자.
    try 블록에 한줄 이상을 넣어 예외가 발생해 실행이 중단되면
    다시 try블록으로 돌아오지 않으므로 주의

    즉 try 블록이 실행되고 에러를 만나면 except 블록으로 이동하는 것이다.

  * 중단될 것 같은 한 줄만 try 블록에 놓는 것이 좋다.

  try / except 와 if / else 를 적절히 섞어 쓸 수도 있다.

  * 사용자가 예외를 발생시킬 만한 값을 입력하면 try / except로 잡을 수 있다!
---------------------------------------------------

들여쓰기는 블록의 시작과 끝을 표시하는 중요한 역할을 한다는 것도 다시한번 기억하자!

-----------------------------------------------------

* 프로그래밍 에서 중요한 것은 같은 작업을 반복하지 않는 것이다.

함수는 하나의 박스라고 생각하시면 됩니다. 프로그래밍에서 함수를 사용하는 이유는
반복적으로 실행되어야하는 코드의 묶음을 프로그래머가 기억하기 쉬운 이름으로 저장하여
반복적으로 호출하고 싶을 때 함수를 사용합니다.

* 재사용 가능한 코드.

def - 정의된 함수를 뜻한다. 역시 콜론으로 끝나고 들여쓰기 된 블럭이 있다.
      내어쓰면 함수가 끝난다.

      실제로 실행되는 코드가 아닌 코드를 기억하는 부분이다.
      즉 저장 단계이다.

      * Stored (and reused) Steps

      def 구문으로 파이썬을 확장시킨 셈.(내장 함수 뿐만 아니라 사용자 정의 함수를 추가한 셈)

* 함수는 반복적으로 호출해야 하는 코드의 묶음을 하나의 블럭으로 만들어 이름을 붙여
  재사용률을 높인 "코드의 묶음"입니다.

------------------------------------------------------

내장함수  max() 문자열의 아스키코드 중 큰걸 찾아준다.
         min() 문자열의 아스키코드 중 작은걸 찾아준다.
         input( ) # ( 괄호 ) 안의 사용자 입력값을 받는 함수
         print("Hello World") # ( 괄호 ) 안의 내용을 출력하는 함수
         float( ) # ( 괄호 ) 안의 값을 float로 변환하는 함수
         int( ) # ( 괄호 ) 안의 값을 int로 변환하는 함수

------------------------------------------------------

자료형 변환

  정수형과 실수형을 표현식에 동시에 사용할 때
  정수는 암시적으로 실수형으로 변환된다.

문자열 변환

  int()와 float()를 문자열에서 정수형으로 변환할 때도 사용할 수 있음

  문자열이 숫자를 포함하지 않으면 에러

------------------------------------------------------

def은 정의하는 것이고
호출(invoke)은 재사용하는 것이다.

return - 함수실행 종료, 함수의 결과값 반환

값을 반환하는 함수를 fruitful 이라고 하는데, 무엇을 생산하기 때문이다.
  fruitful(유익한, 다산의, 비옥한, 열매가 잘 열리는)

되도록 함수는 바로 출력하기보다는 값을 반환하는게 좋다.
함수가 출력하도록 하면 코드가 볼품없어진다.

인자는 함수를 호출할때 전달하는 값을 말하고
매개변수는 함수가 정의된 곳에서 변수처럼 사용하는 것을 말한다.

반환 값을 가질 필요가 없다는 것?
반환 값이 없는 함수는 Void 함수라고 부른다.
* Void (non-fruitful) Functions

--------------------------------------------------------

Repeated Steps - while 루프

* 루프의 종료를 위한 의도적 행위가 없으면 무한히 반복되는루프
  while 루프는 조건문이 거짓이 되기 전까지 계속 실행되기 때문에
  불확정 루프라고 불린다.

  while 반복문에서
    iteration variable 에 아무것도 안하면 무한 루프에 빠질 수 있다.

  break

    break구문을 만나면 그 루프는 끝난다.(위에서 무슨 일이 있었던)
    break는 루프 블럭의 다음으로 이동시킨다.
    break는 루프에서 나가라고 한다.

  continue

    이번 회차의 실행을 멈추고 루프의 제일 위로 올라가서 루프를 계속 실행.

  Break 구문을 가진 Infinite Loops?

    어떤 순간에 빠져나올 수 있기 때문에 무한루프가 아니다.
    루프를 설계하는 유명한 방법 중 하나이다.
    즉 Indefinite Loops 라는 것.(불확정 루프)

  Indefinite Loops

    종료 조건이 복잡해지거나 코드가 길어지고, 코드가 정말 종료될 수 있는지
    불분명해집니다.

  while 루프를 이용해 많은 것을 할 수 있지만
  대부분의 반복문을 만들기 위해 유한 루프라는 것을 사용하게 됩니다.
  (Definite Loops)

-----------------------------------------------------------

for 루프

  유한개의 항목을 가지고 있고 인간의 의도적 행위 없이 주어진 항목들을
  모두 순회하게 되면 종료되는 루프

Definite Loops

    어떤 집합의 원소들에 대해 반복문을 실행하는 것입니다.

파이썬의 for 문은 좀 독특한 편이다.

ex)
  for i in [5, 4, 3, 2, 1] :
    print(i)
  print('Blastoff!')

변수가 헷갈리지 않도록 반복변수는 단수로 설정하자!
리스트는 복수형 변수로 쓰도록 하자!

for 루프는 while 루프에서라면 개별적인 구문이 했어야 하는 일을
한 번에 하고 있다. 먼저 루프를 몇번 실행할지를 결정한다.

Done? no! -> 실행 -> Done? -> yes! -> 끝

* for루프가 i를 설정(i는 조건에 의해 계속 변한다.)하고 코드를 실행한다.

------------------------------------------------------------------

컴퓨터와 인간의 문제 처리 방식이 다르다는 것은 반복문 이해에 가장 중요한 부분이다.

------------------------------------------------------------

Loop Idioms ? - 루프 관용구. 즉 루프를 설계할 때 사용하는 패턴이다.

루프를 활용해 몇가지 패턴을 알게 되면 우리는 다양한 작업들을 수행할 수 있게 됩니다.

집합을 이용한 루프 (Looping through a Set)

  print('Before')
  for thing in [9, 41, 13, 3, 74, 15] :
    print(thing)
  print('After')

최대수 구하는 패턴

  변수 -1을 설정해놓고
  for in 반복문을 이용하여 집합에 있는 원소들을
  설정한 변수와 크기를 비교하여 크기가 더 크다면
  설정한 변수에 그 집합 원소를 저장하는 방식의 아이디어
  (하지만 리스트가 음수이면 작동하지 않는다.)

루프에서 개수 구하기 (Counting in a Loop)

  리스트에 몇 개의 원소가 있는지를 알고자 할 때 우리는 루프를 사용할 수 있습니다.

  루프를 몇 번 실행했는지 횟수를 구하기 위해서 print() 함수와
  0에서 시작하는 카운팅 변수를 도입하고 루프를 실행할 때 마다 1을 더함

루프에서 총합 구하기 (Summing in a Loop)

  루프에서 만난 값을 모두 더하기 위해, 0에서 시작하는 합계 변수를 도입하고
  루프를 실행할 때 마다 값을 더함

루프를 사용하여 평균 구하기

  총합 변수(count)와 합계 변수(sum)를 설정하고 (두 값은 모두 0으로 시작)
  반복문에서 리스트를 사용하여 count를 1씩 올려주면서
  sum에는 원래 sum과 리스트의 value의 합을 저장한다.
  루프가 끝났으면 sum/count 로 계산해주면 평균 값을 구할 수 있다.

부울값을 사용하여 특정 값을 검색하기. (루프를 사용하여 필터링 하기)

  전역공간에 부울 변수를 선언하고,
  리스트를 반복문과 조건문을 이용하여 값이 같으면 부울 값을 바꿔준다.

  * 특정 값을 찾았을 때 해당 루프를 종료하는 것이 더욱 적절하다.

최소수 구하는 패턴

  최대수가 같은 패턴으로 하기에는 얼마나 큰 수를 설정해야 할지 모르기 때문에
  설정한 변수의 값을 None으로 해준다.
  즉 집합의 첫번째 수를 포착할 수 있는 루프를 설계해야한다.

  None 자료형은 단 하나의 값만 가지는 특별한 표식이다.
  불리언은 True와 False 두 값을 가지고
  정수, 실수는 무한 개의 값을 가지고
  None 자료형은 상수이다. 단 하나의 값을 가진다. 공백을 나타내기 위해 자주 쓰인다.

  루프 전에 루프 블럭 밖의 전역 공간에 smallest = None 을 선언해주면
  이는 곧 루프가 시작되기 전에는 확인한 숫자 중 최솟값은 없다는 뜻을 의미한다.

  이러한 방식은 최댓값을 구할 때도 유용하게 쓰인다.

* 구현한 코드가 다뤄야할 숫자에 따라 좋은 가정이 아닐 수도 있다.

* is 연산자는 == 보다 강력하다.

-----------------------------------------------------

is

  == 연산자보다 강력하다.
  비교대상 두 개의 자료형과 값이 같은지 물어본다.
  변수의 자료형과 값 둘다 동등한지를 물어본다.
  동등하면 true, 아니면 false를 반환한다.
  (불리언 자료형이나 None 자로형에만 사용하도록 하자.)

  * 자바스크립트, PHP에서 === 와 같음.

is not

  역시 연산자이다.
  is not none, is not false 이런식으로 적으면 된다.


Indefinite vs Definite

  불확실한, 불분명한, 불명확한 vs 명확한

------------------------------------------------------

Indexing strings []

Slicing strings [2:4]

Looping through strings with for and while

Concatenating strings with +

* 인풋 함수는 문자열을 반환한다.
  사용자 입력으로 들어오는 값은 문자열 타입으로 입력되므로
  입력된 값으로 다른 무엇인가를 하기를 원한다면 적절한 타입 변환을 해줘야 한다.

문자열 타입과 관련하여서는 타입 변환, 인덱싱, len 함수, for 루프 활용을 이해하고 사용할 수 있으면 됨.

문자에 대한 인덱스는 0부터 시작한다.

논리연산자로서의 in

  in 키워드는 어떤 문자열이 다른문자열에 "포함" 되는지
  확인하기 위해서도 사용된다.

  in 표현식은 참 또는 거짓 값을 반환하는 논리 표현식이며 if 구문에 사용될 수 있다.

  ex) fruit = 'banana'
      'n' in fruit
      True 반환

문자열 라이브러리

  파이썬은 여러 개의 문자열 함수를 정의하는 문자열 라이브러리가 존재

  * 메소드는 특수한 형태의 함수 호출이다.
    함수에 매개변수로 전달하는 대신 객체 온점 함수 이름을 적는 것으로
    일어나는 함수 호출이다.

    예를들면 len(x)는 객체 지향이 아니다.
    객체 지향 함수라면 X.무언가() 이다.

  문자열 변수와 상수에 내장되어있는 함수
  모든 문자열에 이미 내장되어 있음

  lower() - 함수를 문자열 변수에 붙임으로써 호출
            원본 문자열을 수정하지 않고 새로운 소문자 문자열 반환

  upper() - 새로운 대문자 문자열 반환

  find() - 문자열 탐색. 하위 문자열을 다른 문자열에서 탐색 가능.
           find() 하위 문자열의 첫 번째로 나타내는 위치를 검색
           찾지 못하면 find()는 -1을 반환.

           * 문자열 좌표는 0에서 시작한다는 것에 주의

  replace() - search and replace. 매우 유용하다.
              ex) 문자열에 있는 모든 x를 탐색하고 찾아낸 x를 y로 대체한다.
              이 메소드는 하나 이상의 일을 한다.
              하나를 찾는게 아니라 문자열의 모든 문자를 찾아서 대체한다.

  공백 제거 (종종 문자열의 끝과 마지막에 남아있는 공백을 제거)

    lstrip() - 문자열 왼쪽의 공백을 제거
    rstrip() - 문자열 오른쪽의 공백을 제거
    strip() - 문자열 시작과 끝에 있는 모든 공백을 제거

  Prefixes - 접두사

    startswith() - 시작 문자열 찾기. 결과값은 불리언 타입으로 반환된다.
                   해당 문자열로 시작한다면 True, 그렇지 않다면 False

* 파이썬 3의 큰 특징 중 하나는 모든 내부 문자열이 유니코드라는 것이다.

u 는 유니코드 연산자. 파이썬 2에서는 u 붙이면 아시안 문자들은 유니코드로 인식했다.
사용하기 훨씬 어려웠음. (스페인, 프랑스어도)
파이썬 3부터는 문자 집합을 인식하기 시작했다.

--------------------------------------------------

파일

* 파일이 어떠한 방식으로 열리는 이해하고 파일을 열기 위한 open() 함수를 사용할 수 있다.
  open 함수는 파일을 읽기 가능하게 해준다.

open() 사용

사용법

  핸들 = open(파일명,모드)

  파일을 조작하는데 쓰는 핸들을 반환함

  파일명에는 문자열이 들어감

  모드에 매개 변수를 넣는 것은 선택 사항이며 파일을 읽으려면 'r'을, 파일에 쓰려면
  'w'를 입력

* 핸들은 파일에 접근할 수 있게 도와준다.
  파일 자체도 아니고 데이터도 아니다. 단지 파일에 접근하는 창구일 뿐이다.

개행 문자

  \n 은 다른 문자와 같이 하나의 문자이다.

  각 줄이 끝날 때 이를 알리기 위해 "개행 문자"라고 부르는 특수한 문자를 사용한다.

    * 개행 문자는 한글자이다. 두 글자가 아님.

  줄바꿈을 의미한다.

  텍스트 파일은 각 줄 끝에 개행 문자가 있다. 눈에 보이지 않을 뿐.(엔터키 입력시)

  개행 문자는 그 자체로 문자임을 알아야 한다!

    * 우리는 모든 줄이 개행 문자로 끝난다는 것을 인지하고 있어야 한다!

파일을 읽는 일반적인 방법?

순차적으로 파일 다루기(File Handle as a Sequence)

  파일을 여러 줄의 문장으로 보고 for 루프를 이용하여 (순차적으로) 파일을 읽는 것이다.

  ex)
      xfile = open('mbox.txt')
      for cheese in xfile:
        print(cheese)

  C나 C++ 등의 다른 프로그래밍 언어는 while 루프에서 파일이 끝나는 조건도 적어줘야 해서
  이런 반복문을 작성하는 것 더 어렵다.
  하지만 파이썬은 멋지고 쉽게 한다.

파일의 줄 수 세기(Counting Lines in a File)

  for문을 이용하여 각 줄을 읽는다.
  줄을 세고 줄의 수를 출력한다.

  fhand = open('mbox.txt')
  count = 0
  for line in fhand:
    count = count + 1
  print('Line Count:', count)

파일 전체 읽기(Reading the *Whole* File)

  핸들로 사용되는 변수 fhand가 있으면
  fhand.read()를 이용하자.

  ex)
      >>> fhand = open('mbox-short.txt')
      >>> inp = fhand.read()
      >>> print(len(inp))
      94626
      >>> print(inp[:20])
      From stephen.marquar

파일 내용 탐색(Searching Through a File) - 전형적인 첫번째 방법

  ex)

    fhand = open('mbox-short.txt')
    for line in fhand:
      line = line.rstrip()
      if line startswith('From:') :
        print(line)

    From: stephen.marquard@uct.ac.za
    From: louis@media.berkeley.edu
    From: zqian@umich.edu

    * 공백은 출력되지 않는 모든 것을 의미한다.
      개행 문자는 출력되지 않는 공백 문자이므로 rstrip으로 지울 수 있다!

continue문으로 넘어가기 (Skipping with continue) - 두번째 방법

  건초 더미에서 바늘 찾는 법?
  모든 내용을 루프에 넣고 우리가 원하는줄을 골라내보자!

  continue 문을 사용하여 편리하게 줄을 넘길 수 있음

  예시)4

    fhand = open('mbox-short.txt')
    for line in fhand:
      line = line.rstrip()
      if not line.startswith('From:') :
        continue
      print(line)

  * 관심없는 줄을 생략하고 계속 내려감. 여러 줄을 생략한다.
    선별한 줄로 다음 작업을 진행할 수 있다.

파일 이름 입력 받기

    사용자가 파일의 이름을 직접 입력해야 하는 경우도 있을 수 있습니다.
      ex) fname = input('Enter the file name: ')
          try:
            fhand = open(fname)
          except:
            print('File cannot be opend: ',fname)
            quit()

          나머지 로직
          ...
          .
          .

    파일명을 적절힌 입력한다면 문제가 없겠지만 잘못된 파일명을 입력했을 때
    처리방법을 생각할 필요가 있습니다. 이미 배운 try, except문을 적절히 활용하면
    발생할 수 있는 오류 상황을 적절하게 해결 할 수 있을 것입니다.

* quit()은 특별한 함수로 실행되면 아무것도 반환하지 않는다
  이것이 파이썬 프로그램을 에러 없이 조용하게 끝내는 방법이다.

  오류를 발견하여 작동을 중지할 때 아주 좋은 도구이다.

# File Handle?
# 텍스트 파일을 읽는 하나의 표준화된 형태
# 순차적으로 텍스트 파일을 읽는다.

---------------------------------------------------------

컬렉션이란?

  하나의 변수에 여러 값을 넣는 것이 가능하도록 하는 것을 컬렉션이라고 한다.

  리스트, 딕셔너리, 튜플 등이 있다.


리스트

  필요에 따라 하나의 변수에 많은 데이터를 넣을 수도 있다.
  이를 리스트라고 한다.

문자열은 변경이 불가능하다.

  문자열은 fruit[0] = 'b' 이런 방식으로
  문자열의 내용을 변경할 수 없다.
  즉 인덱스 연산자를 사용하여 문자열의 요소 변경이 불가능하다.
  변경하려면 내장함수등을 사용하여 새 문자열을 만들어야한다.

  ex) x = fruit.lower()

리스트는 변경이 가능하다.

  인덱스 연산자를 사용하여 리스트의 요소 변경이 가능하다.

  ex) >>> lotto = [2, 14, 26, 41, 63]
      >>> lotto[2] = 28
      >>> print(lotto)
      [2, 14, 28, 41, 63]

len() 함수

  아무 집합이나 시퀀스(예) 문자열)를 받아 원소의 개수를 반환한다.

  문자열안의 문자 개수를 세어주거나, 리스트의 경우 리스트 안의 원소 개수를 알려준다.

  * len 함수는 원소의 개수가 몇 개인지 알려준다

range() 함수

  range() 함수는 인자로 전달되는 값에 따라서 숫자로 이루어진 리스트를 반환한다.

  * 0부터 매개 변수로 넣은 값보다 1 작은 범위의 수까지로 구성된 숫자 리스트를 반환

  ex) >>> print(range(4))
      [0, 1, 2, 3]
      >>> friends = ['Joseph', 'Glenn', 'Sally']
      >>> print(len(friends))
      3
      >>> print(range(len(friends)))
      [0, 1, 2]

range() 와 len() 을 이용한 두가지 루프

  friends = ['Joseph', 'Glenn', 'Sally']

  for friend in friends :
    print('Happy New Year:', friend)

  for i in range(len(friends)) :
    friend = friends[i]
    print('Happy New Year:', friend)

파이썬은 연산자에 의해 객체 지향적 접근법으로 다가간다.

Concatenating lists using +

  + 연산자를 사용하여 존재하는 두 리스트들을 하나의 새로운 리스트로 합칠 수 있다.

Lists can be sliced using :

  리스트도 :(콜론)을 이용해 자를 수가 있습니다.
  여기서 중요한 것은 예를 들어 t[1:3]과 같은 경우
  3번째 인덱스에 해당하는 항목은 포함되지 않는다는 것입니다.

  예시)
  >>> t = [9, 41, 12, 3, 74, 15]
  >>> t[1:3]
  [41,12]
  >>> t[:4]
  [9, 41, 12, 3]
  >>> t[3:]
  [3, 74, 15]
  >>> t[:]
  [9, 41, 12, 3, 74, 15]

  * 문자열과 마찬가지로, 괄호 안의 두 번째 숫자 "직전"까지(미만)만 포함한다.

리스트 원소 탐색

  >>> some = [1, 9, 21, 10, 16]
  >>> 9 in some
  True
  >>> 15 in some
  False
  >>> 20 not in some
  True

  위 코드 처럼 in 과 not in 을 이용하여 특정 원소가 리스트에 있는지 확인이 가능하다.

dir() 메소드

  특정 타입에서 사용할 수 있는 메소드의 목록들을 볼 수 있는 함수도 있습니다.
  ex)
    x = list()
    print(dir(x))

List Methods

  리스트를 잘 조작하기위해 내장된 함수(메소드) 들이 많다.

  count는 리스트 요소가 몇 개 들어있는지 알려준다.
  extend는 리스트 끝에 원소를 추가해준다.
  index는 리스트의 특정 원소를 찾아 위치 값을 반환한다.
  insert는 리스트 중간에 요소를 삽입하여 리스트가 확장될 수 있도록 한다.
  pop은 리스트에서 마지막 원소를 꺼내고
  remove는 특정 원소를 삭제하고
  reverse는 리스트 내 원소 배열 순서를 뒤집으며
  sort는 값에 따라 원소를 정렬한다.
  append 메서드를 이용하여 빈 리스트에 요소들을 추가할 수 있다.
    ex)
      >>> stuff = list()
      >>> stuff.append('book')
      >>> stuff.append(99)
      ['book', 99]
      >>> stuff.append('cookie')
      >>> print(stuff)
      ['book', 99, 'cookie']

from Scratch? - 처음부터. (경마경기 선 그은데부터 출발한다는 데에서 유래한 영어 숙어

hou = list() ?

  파이썬에게 빈 리스트를 만들고 빈 리스트를 할당하라는 생성자 형태의 문법이다.
  리스트이긴 하지만 변수 hou에 할당된 빈 리스트이다.


Best friends: Strings and Lists - 문자열과 리스트는 잘 어울려 사용된다.

  split() 메소드

    빈 공간, 공백을 기준으로 문자열을 작게 나누고 나뉜 문자열로 구성된 리스트를 생성한다.
    이 문자열은 단어로 볼 수 있다.

    * 인덱스를 이용하여 특정 단어에 접근하거나 모든 단어에 대해 루프를 실행할 수 있다.

    탭이나 줄 바꿈, 또는 다른 문자에 대해서도 분할이 가능하다.
    split 메소드의 인자에 원하는 문자열을 입력하면 된다.

    * 명시적으로 구분자를 넣어주지 않으면, 빈칸을 구분자로 인지하고 나누게 됩니다.

Guardian Pattern - 위험한 코드로부터 에러가 날 수 있음을 방지해준다.

[Algorithm]Short circuit evaluation - 최단평가

  Short Circuit Evaluation이란 AND 혹은 OR의 연산에 있어서
  결과가 확실하게 예측이 되었을 때 뒤에 나머지 연산을 실행하지 않고
  답을 내버리는 경우를 의미합니다.

  AND 연산의 경우

    AND연산의 경우에 false가 우선 나와버리면 AND 뒤에 나오는 연산은 생략이됩니다.

  OR 연산의 경우

    OR연산의 경우에 true가 우선 나와버리면 OR 뒤에 나오는 연산은 생략이됩니다.

-----------------------------------------------------

리스트

  순서대로 정리된 컬렉션이다. 데이터를 추가하면 항상 리스트의 끝에 추가되고 0부터 n-1번 위치까지
  순서대로 n개의 원소가 저장되어 있다.

딕셔너리(Dictionary)

  리스트와 달리 순서라는 것이 없다.
  대신 키(Key)라는 것이 존재한다.
  마치 물건에 포스트잇으로 라벨을 붙이는 것과 비슷하다.
  딕셔너리는 dict()라는 생성자를 통해 생성할 수 있다.
  변수 = {}로 역시 빈 딕셔너리를 만들어 줄 수도 있다
  키는 같은 이름으로 중복이 불가능하다. (값은 같아도 됨)

  * 이렇게 키와 값이 연결되는 개념을 보통 연관 배열이라고 한다.
    접근하는 방식은 리스트와 비슷하나, 키를 가지고 접근한다는 차이점이 있다.

    PHP / Perl 에서는 property maps
    Java에서는 hash maps
    C# / .Net 에서는 property bags 라고 한다.

-----------------------------------------------------

딕셔너리를 활용하여 데이터의 빈도수를 측정할 수 있다.

딕셔너리의 일반적인 활용법 - 히스토그램

  히스토그램이란? 데이터의 빈도를 나타내는 그래프이다.
  히스토그램은 빈도 수를 세는 프로그램이다.

    - 셀 때마다 해당되는 키의 값에 1씩 더해주는 방식.

딕셔너리에 없는 키를 찾으려고하면 오류가 발생하게 됩니다.

  딕셔너리에 in 연산자를 사용함으로써  Traceback 에러를 피할 수 있다.
  (찾으려는 키가 없다면 에러가 나지만, in으로 포함관계인지 알아본다면 false 리턴한다.)

  ex)

    counts = dict()
    names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']
    for name in names :
      if name not in counts:
        counts[name] = 1
      else :
        counts[name] = counts[name] + 1
    print(counts)

    # {'csev': 2, 'zqian': 1, 'cwen': 2}

get 메소드 (딕셔너리 관련 함수)

  * 코드를 간결하게 만들 수 있으므로 get() 메소드를 꼭 기억하자

  get(x) 함수는 x라는 key에 대응되는 value를 돌려준다.
  즉 Key로 Value얻기.

  두번째 매개변수는 키에 대응되는 값이 없을시 설정되는 기본값을 의미.

  이와 같이 딕셔너리에 존재하는 키인지 아닌지 여부에 따라 처리하는 패턴은
  get이라는 메소드를 사용해서 간결하게 해결할 수 있습니다.
  여기에서 counts.get(name, 0)의 의미는 counts 딕셔너리에 name이라는 키가
  존재할 경우 name에 대한 값을 불러오고, 그렇지 않을 경우에는 counts 딕셔너리에
  name이라는 키에 0이라는 값을 갖는 데이터(default)를 추가하라는 의미입니다.

  ex)

    counts = dict()
    names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']
    for name in names :
      counts[name] = counts.get(name, 0) + 1
    print(counts)

    # {'csev': 2, 'zqian': 1, 'cwen': 2}

    키가 아직 딕셔너리에 업으면 get을 사용하여 기본값으로 0을 줄 수 있음.
    그리고 1을 더함.

    앞으로는 이런 패턴을 자주 보실 것입니다.

딕셔너리에는 저장되는 순서가 없다고 해도, for 문을 작성하여
딕셔너리의 모든 원소를 돌 수 있습니다.

  - 딕셔너리의 모든 키를 거쳐가며 값을 찾는다.

items() 메소드

  Key, Value 쌍 얻기(items)
  두개의 반복 변수를 사용하여 딕셔너리의
  키-값 쌍을 반복해서 다룰 수 있다.

      jjj = { 'chuck' : 1 , 'fred' : 42, 'jan': 100}
  ex) for aaa,bbb in jjj.items() :
          print(aaa, bbb)
  키와 값의 쌍으로 된 리스트를 반환한다.

* 딕셔너리는 컬렉션 중 가장 강력하다.
  컬렉션이 무엇인지 이해하기 위해 리스트와 딕셔너리를 보는게 좋음.
  하나 이상의 대상 자기 내부에 포함하여 다룰 수 있게 하는 파이썬의
  도구이기 때문.

clear() 메소드

  Key: Value 쌍 모두 지우기

  clear() 함수는 딕셔너리 안의 모든 요소를 삭제한다.
  빈 리스트를 [ ], 빈 튜플을 ()로 표현하는 것과 마찬가지로 빈 딕셔너리도 { }로 표현한다.

keys() 메소드

  Key 리스트 만들기

  ex)
    >>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
    >>> a.keys()
    dict_keys(['name', 'phone', 'birth'])

values() 메소드

  Value 리스트 만들기

  ex)
    >>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
    >>> a.values()
    dict_values(['pey', '0119993323', '1118'])

---------------------------------------------

튜플(Tuple)

  Tuple are like lists.
  but... Tuples are "immutable"

  리스트는 바뀔 수 있지만 튜플은 바뀔 수 없다. 아이템 할당이 안됨 ( ex) x[2] )
  리스트와 기능은 거의 같지만 리스트와는 다르게 소괄호를 사용한다.

  * 딕셔너리는 {}, 리스트는 [], 튜플은 ()

  튜플은 한번 할당이 되면 바꿀 수 없다.
  왜 이렇느냐? 바로 효율성 때문이다.
  용량도 적게 차지하고, 접근도 빠르고, 리스트보다 효율적이다.
  그냥 값을 저장하고 접근만 할거라면 리스트보다 튜플이 낫다.
  리스트는 sort() 메소드가 되지만 튜플은 불가능하다.
  리스트 append()나 reverse()등 변경하는 작업들은 전부 튜플에서 불가능하다.

  t = tuple()
  dir(t)
  해보면 count랑 index 메소드는 사용 가능한 것을 알 수 있다.

  즉 튜플은 제한이 있는 리스트이다. 왜 사용할까? 더 효율적이기 때문.
  보다 효율적으로 메모리를 활용 가능

튜플을 사용하기 좋을 때?

  임시로 사용하는 변수를 만들 때이다.
  어차피 임시로 사용하고 버리는 변수이니 간단하고 깔끔하게 사용이 가능하다.

  리스트는 보다 다양한 것을 구축하는데 쓰인다.

좌변에 변수를 가진 채로 선언할 수 있다.


여러 값에 대해 비교 가능

  튜플의 또다른 장점은 여러 값에 대해 비교가 가능하다는 점입니다.

  비교의 방법은 각 튜플의 가장 왼쪽 값끼리 비교한 후 둘의 값이 다를 경우에는
  나머지 값들을 비교하지 않고 큰지 작은지 여부를 판단합니다.

  만약 가장 왼쪽 값이 동일할 경우에는 그 다음 값을 비교하고,
  그 값도 같으면 또 다음 값을 비교하는 형태로 비교가 진행됩니다.

  같으면 패스하고 맞으면 true 반환.

* 딕셔너리에서 items() 메소드는 튜플로 된 리스트를 반환한다.

  for문과 함께 사용할 때?

    c = {'a':10, 'b':1, 'c':22}
    for k, v in c.items() :
      ...

    여기서 k, v는 (k,v) 인 튜플이고, 소괄호는 생략할 수도 있다.

* sorted() 메소드는 시퀀스를 인자로 받아 키를 기준으로 정렬시키고 정렬된 시퀀스를 리턴한다.

    예)
        >>> d = {'a':10, 'b':1, 'c':22}
        >>> t = sorted(d.items())
        >>> t
        [('a', 10), ('b', 1), ('c', 22)]
        >>> for k, v in sorted(d.items()):
        ...    print(k, v)
        ...
        a 10
        b 1
        c 22

튜플, 리스트, 딕셔너리를 이용해서 값을 오름차순으로 정렬(쉽게 쓴 버젼)

        c = {'a':10, 'b':1, 'c':22}
        print( sorted( [ (v,k) for k,v in c.items() ] ) )
        # [(1, 'b'), (10, 'a'), (22, 'c')]

        파이썬에서 []는 리스트임을 의미한다.
        (v,k)라고 써준 것은 리스트가 튜플인 것을 의미한다.
        append 함수를 써주지 않아도 고오급 언어인 파이썬에서
        for 반복문을 사용하여 튜플을 리스트에 차곡차곡 넣어줄 수 있음.

        값을 기준으로 정렬해주고 (sorted()메소드 사용)
        정렬된 후에는 키와 값의 쌍으로 출력할 수도 있다.

파싱이란?

  어떤 data를 원하는 form으로 만들어 내는 것
  데이터를 원하는 형태 또는 양식으로 만들어 내는 것입니다.

----------------------------------------------------

영어상식 - Fine-tuning은 미세조정 이라는 뜻이다.
          handout - 유인물 (수업이나 회의에 참석한 사람에게 전달되는 정보가 적힌 종이)
          print - 인쇄, 신문, 압박

Regular Expressions(정규 표현식)


^ Matches the beginning of a line
$ Matches the end of the line
. Match any character
\s Matches whitespace
\S Match any non-whitespace character
* Repeats a character zero or more times
*? Repeats a character zero or more times (non-greedy)
+ Repeats a character one or more times
*? Repeats a character one or more times (non-greedy)
[aeiou] Matches a single character in the listed set
[^XYZ] Matches a single character not in the listed set
[a-z0-9] The set of characters can include a range

: 는 특수문자가 아니라 그냥 문자이다.
[] 는 문자 하나를 나타낸다. 대신 괄호 안 조건에 포함되는 문자여야 한다.

  [^ ]는 \S 와 같다. 공백이 아닌 모든 문자를 의미한다.

() 는 정규식에 포함되지 않는다. 추출 시작점과 끝점을 지정해주는 역할만 한다.
   괄호를 사용하면 정규표현식이 좀 더 정교해진다.

   매칭에 비포함되며 추출될 문자열의 시작과 끝 지점을 지정해주면 된다.


정규표현식은 문자열 비교나 처리를 하기 위한 아주 똑똑한 와일드 카드 표현식이다.
정규 표현식을 파이썬과 함께 사용하려면 import re 로 정규식 라이브러리를 가져와야 한다.

관련 메소드

  re.search() 매개 변수를 받아 문자열 내에서 검색하는 함수

    re.search() 메소드는 정규표현식과 매치되는 문자열이 있으면
    True를 리턴하고, 아닐경우 False를 리턴한다.

    예 )
        아래는 정규표현식라이브러리를 불러와 (import re)
        사용한 함수지향적 코드.

          * 여기서 line은 매개변수

          if re.search('From:', line):
            print(line)

            * find가 하는 일을 정규식을 이용해서 한것이다.

        아래는 객체지향적인 코드

          if line.find('From:') >= 0:
            print(line)

            * 없으면 -1 리턴하므로 0보다 작으므로 if문에서 false가 되고,
              있으면 인덱스를 나타낼 것이므로 0이상 큰 숫자로 인해 True가 리턴되고 라인이 프린트된다.

    if line.startswith('From'): 은 정규표현식을 사용한 아래 코드와 같다.
    if re.search('^From:', line):

      차이점은 문자열과 관련된 내장 메소드(일반 함수)를 썼느냐,
      아니면 정규 표현을 사용했느냐 이다.

  * 문자열 함수를 전부 합쳐도 정규식으로 할 수 있는 것보다
    기능이 제한되어있기 때문에 정규식을 사용하면 더욱 효과적이다!

  re.findall() 문자열을 쭉 순회하면서 정해진 패턴을 만족하면 추출하는 함수

    re.findall() 을 사용하면 정규식에 매칭되는 부분 문자열을 모은 *리스트*를 리턴한다.
    첫번째 매개변수는 패턴(문자열로 입력한다.), 두번째 매개변수는 메소드를 적용할 변수를 의미한다.

    예)
        >>> import re
        >>> x = 'My 2 favorite numbers are 19 and 42'
        >>> y = re.findall('[0-9]+',x)
        >>> print(y)
        ['2', '19', '42']
        >>> y = re.findall('[AEIOU]+',x)
        >>> print(y) # 조건에 만족하는 부분이 없으므로 빈 리스트를 리턴할 것이다.
        []

        * 만족하지 않으면 아이템이 없는 빈 리스트를 리턴하므로
          제대로 작동하는지 수동으로 꼭 체크해봐야한다.

* 정규표현식 라이브러리를 사용하여 문자열에서 데이터를 추출할 수 있다!

수량자는 일반적으로 탐욕적인 방식이다. 최대한 길게 더 찾으려고 한다.
수량자 뒤에 ? 문자를 추가하여 Non-Greedy Matching을 사용할 수 있다.(게으른 수량자)

대부분은 그렇지 않지만 정규표현식에서는 탐욕적인게 기본이고 탐욕적이지 않은 것은 선택사항임.
정규식은 욕심쟁이! 그렇지만 짧게도 가능하다.

repeat characters 인 *와 +는 가장 길게 매칭되는 경우를 검색한다.
?를 붙여주면 욕심을 버릴 수 있음. ?를 붙이면 가장 짧은 경우를 검색할 수 있다.

이메일 찾을 때 패턴

  \S+@\S+ ( 공백이 아닌문자 하나이상 여러개,사이는 @, 공백이 아닌문자 하나이상 여러개 )
  탐욕적으로 작동.

패턴 추출 및 최댓값 찾기

  지금까지 배운 내용들을 종합하면 텍스트 파일에서 특정 패턴을 찾고,
  그 패턴들 중 가장 큰 값이 어떤 것인지 찾을 수 있다.

  import re
  hand = open('mbox-short.txt')
  numlist = list()
  for line in hand:
      line = line.rstrip()
      stuff = re.findall('^X-DSPAM-Confidence: ([0-9.]+)', line)
      if len(stuff) != 1 :  continue
      num = float(stuff[0])
      numlist.append(num)
  print('Maximum:', max(numlist))


예외 문자(Escape Character)

  특수 문자로 이루어진 패턴을 찾으려면 어떻게 해야 할까?

  역슬래시(\)를 사용하면 된다.

  예를 들어, '$' 문자가 포함된 패턴을 찾고 싶을 때는 다음과 같이 코드를 작성할 수 있다.

  import re
  x = 'We just received $10.00 for cookies.'
  y = re.findall('\$[0-9.]+',x)
  print(y)

  # ['$10.00']

* 정규표현식에서는 ()로 추출할 부분을 지정할 수 있다! 이것을 기억하면 더 섬세한 추출이 가능해진다!!

----------------------------------------------------------------

TCP / UDP 프로토콜

    TCP - 연결형 통신 ( 소켓끼리 연결을 하고, 한번 연결하면 연결한 상태를 유지한다. )

        중간에 데이터가 빠진 부분이 있으면 빠진걸 다시 보내줌. 즉 신뢰성 있는 프로토콜이다.
        가장 낮은 계층에서 네트워크를 작동시킨다.

        네트워크에서는 15~20번의 패킷과정을 거친다.

        three way handshake 간다?->응 와->감

            * 중요한 파일전송 (중간에 하나라도 빠지면 안되는 것들 전송할 때 쓰인다.)에 쓰인다.

    UDP - 비연결형 통신 ( 소켓이 있으면 데이터를 한번보낸다. 그러면 끝. 잘못받았는지 받았는지는 관심 없음.)

        장점은 속도가 빠르다. 하지만 잘 받았는지 안받았는지 신경 안쓴다.
        데이터를 담아서 그냥 보내면 끝이다.

            * 스트리밍 , 전화에 쓰인다. ( 데이터가 중간에 유실되더라도 큰 지장이 없음. )

패킷?

  컴퓨터 네트워크가 전달하는 데이터의 형식화된 블록을 의미한다.
  패킷은 데이터의 한 단위이다.

홉 (네트워크 관련)

  홉이란 영어 뜻 자체로는 건너뛰는 모습을 의미

  ㅇ 데이타통신망에서 각 패킷이 매 노드(또는 라우터)를 건너가는 양상을 비유적으로 표현

  홉(hop)은 컴퓨터 네트워크에서 출발지와 목적지 사이에 위치한 경로의 한 부분이다.
  데이터 패킷은 브리지, 라우터, 게이트웨이를 거치면서 출발지에서 목적지로 경유한다.
  패킷이 다음 네트워크 장비로 이동할 때마다 홉이 하나 발생한다.
  홉 카운트(hop count)는 데이터가 출발지와 목적지 사이에서 통과해야 하는
  중간 장치들의 개수를 가리킨다.

  저장 전달과 기타 레이턴시가 각 홉을 통하여 발생되므로 출발지와 목적지 사이에서
  홉의 수가 많아지면 실시간 성능이 저하될 수 있다.

소켓

한 컴퓨터의 프로세스와 다른 컴퓨터의 프로세스 사이에 어떤 연결이 있다.
양쪽 다 그 연결을 통해 데이터를 주고 받을 수 있다.
이것들을 소켓이라고 부른다.

포트 번호

  연결하고 싶은 포트 번호를 원하는 프로세스로 연결해준다.

  ex) 이메일은 포트 25, 즉 내선번호 25
      비보안 로그인은 23번,
      웹은 80,
      로컬메일 클라이언트등등
      프로토콜을 이용해서 가져온다.

보통 어디가 어떤 포트인지 관례적으로 정해져있어서
어떤 포트에 통신을 시도해야 하는지 알 수 있다.
80 웹서버
23번 포트 Telnet 서버
등등..

일반적으로 사용되는 기본 포트가 정해져있다.
해당 포트는 네트워크 애플리케이션 프로세스에 대해 데이터를 제공.
포트는 전화번호, 내선번호라고 할 수 있다.

소켓

  * 파이썬에서는 소켓에 굉장히 쉽게 접근이 가능하다.
  import socket 라이브러리를 사용하자.
  * 스트림베이스 소켓을 이용한다.(두번째 매개변수 socket.SOCK_STREAM).
    인터넷을 통한 통신에 적합하다.
    mysock.connect(('URL',PORT번호))

소켓만들기

  import socket
  mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 소켓 만들기
  mysock.connect( ('data.pr4e.org', 80) ) # 인터넷 연결. 이 호스트로 전화를 걸어 라는 뜻

* 소켓을 통해 어떤 데이터를 송신하고 수신할 수 있다.

프로토콜?

  전화에서 먼저 얘기하는 사람을 의미합니다.

  우리가 프로토콜을 사용해서 할일은 사이에서 통신 규칙, 규약을 만들어주는 것이다.

HTTP

  하이퍼텍스트 전송 프로토콜. Hypertext Transfer Protocol
  웹을 위해 개발된 통신규약입니다.
  HTML, 이미지, 문서 등을 가져옵니다.
  기본 컨셉은 연결 - 문서 요청 - 문서 수신 - 연결 종료 입니다.

  인터넷 표준을 따르며, 요청-응답 반복이 이루어진다.
  (이러한 표준은 국제 인터넷 표준화 기구인 IETF에 의해 관리되고 있음.)

HTML

  HTTP 통신에서 돌려받는 문서의 형식이다.

  * 브라우저는 이러한 정보를 받아서 HTML과 CSS, 자바스크립트 등의 정해진 규칙대로 렌더링해서
  웹페이지를 만들어내는 것이다.

Telnet

  소켓을 통해 호스트 포트에 연결할 수 있는 프로그램.

  옛날에 사용되던 프로그램입니다.
  서버에 로그인하는 방법으로 사용되었습니다.
  데이터를 엄호화하지 않기 때문에 지금은 사용되지 않고 있습니다.

  서버에서는 몇가지 헤더가 넘어온다.
  헤더는 수신할 문서에 대한 정보(메타데이터)이다.
  예를 들어 text/html을 받았다면 남아있는 부분이 HTML 형식이라는 뜻이다.

해커들은 좀 더 직접적으로 프로토콜을 다루는 법을 안다.
정말 재능있는 해커들은 커맨드 라인을 사용한다.
해커들은 네트워크가 어떻게 작동하는지 잘 이해하고 그걸 활용해서 해킹한다.
해킹을 막으려는 개발자들보다 훨씬 잘 알고 있다.
그런 이유때문이라도 커맨드 라인에 익숙해지는 것이 좋다.


* 토막지식

  CR LF 캐리지 리턴, 라인피드?

    CR은 현재 위치를 나타내는 커서를 맨 앞으로 이동시킨다는 뜻이고,
    LF는 커서의 위치랄 아랫줄로 이동시킨다는 뜻이다.
    이 두 동작을 합치면 뉴라인('\n'), 개행문자와 동일한 동작을 하게된다.

    줄바꿈을 한다는 것은 Windows의 CR+LF가 모든 동작을 그대로 표현하는 것과 같다.
    OS마다 코드 조합이 다르다. CR+LF, CR, LF 등으로 다르다.
    둘 중 하나만 있어도 뉴라인으로 간주하기도 한다.

메타데이터 vs 데이터

  메타 데이터는 데이터에 대한 데이터이다.
  즉 다른 데이터를 설명해주는 데이터이다.
  구조화된 정보를 분석, 분류하고 부가적 정보를 추가하기 위해
  그 데이터 뒤에 함께 따라가는 정보를 말한다.

파이썬으로 간단한 웹 브라우저 만들기

  import socket

  mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 아직 아무 데이터하고도 연결되지 않은 소켓 핸들러 생성
  mysock.connect(('data.pr4e.org', 80)) # 소켓을 대상에 연결
  cmd = 'GET http://data.pr4e.org/romeo.txt HTTP/1.0\r\n\r\n'.encode() # 이해가 가지 않는다면 RFC를 확인하자. 소켓에 보낼 문자열 준비 + 전송을 위한 encode() unicode -> UTF-8
  mysock.send(cmd) # 문자열 전송

  while True:
      data = mysock.recv(512)
      if (len(data) < 1): # 소켓으로부터 받아온 데이터가 1보다 작다면(없을 때) break한다.
          break
      print(data.decode(),end='')
  mysock.close()

* 파이썬에 있는 문자열은 유니코드로 되어있고, 전솧알 때는 UTF-8 형식으로
  전송해야 하기 때문이다. 내부에서 유니코드를 UTF-8 형식으로 인코딩해주어야 한다.
  encode()를 통해 UTF-8 데이터를 준비하고 전송한다.
  인코딩이 끝나면 전송을 진행한다. (mysock.send(cmd) 부분)

  출력할때는 UTF-8에서 파이썬 내부 포맷인 유니코드 형태로 변경해줘야 한다.
  위 코드는 데이터 블록을 계속 꺼내와서 작업을 하면 출력하고, 모든 데이터가 처리되면
  연결을 종료하는 로직이다.

* 우리가 하려고 하는 것은 소켓을 열고 명령을 보내고 데이터를 받는 것이다.

------------------------------------------------

• UTF-16 – 길이 고정됨 - 2 바이트
• UTF-32 – 길이 고정됨 - 4 바이트
• UTF-8 – 1-4 bytes
* UTF-8 은 시스템 간에 데이터를 교환할 때
  가장 실용적으로 추천되는 인코딩 형식입니다

ASCII

  아스키 코드는 1 byte로 영문자와 숫자, 그리고 일부 특수문자들을 표현할 수 있습니다.
  순서와 관련된 함수인 ord()를 써서 아스키 코드 값을 알아낼 수 있다!

  예)
      print(ord('H'))
      # 72
      print(ord('e'))
      # 101
      print(ord('\n'))
      # 10

  ord() 함수를 사용하면 각각의 문자에 대한 아스키 코드 값을 확인할 수 있습니다.
  ord() - ASCII 문자에 대응되는 숫자를 리턴

파이썬 3 에서 모든 문자열은 유니코드이다.
파이썬 2일 때는 바이트에 해당하는 아스키코드였다.

UTF-8은 ASCII 까지 포함한다.

네트워크로 부터 데이터를 받은 경우 데이터를 반드시 올바른 형식으로
데이터를 해석하거나 디코딩 해주어야 한다.

파이썬 프로그램 내부에서 문자열은 유니코드이며 제대로 표현될 것이다.

네트워크는 UTF-8 형식을 사용한다.(대부분)
아스키코드여도 호환되긴 한다.
UTF-8은 1바이트부터 4바이트까지 동적으로 자동 조절해준다.

파이썬에서 네트워크 데이터를 받아 오는 순서. (Unicode와 UTF-8)

  1. 파이썬(문자열이 유니코드)인 상태
  2. encode()사용->UTF-8로 변환됨
  3. send()메서드로 소켓에 보내기
  4. 네트워크 소켓
  5. recv() 메서드로 파이썬에서 데이터를 다시 받는다.
  6. decode()이용하여 문자열을 UTF-8에서 유니코드로 변환
  7. 문자열이 유니코드가 되었다.(파이썬의 기본 문자열 상태)

* 파이썬의 외부와 데이터를 주고 받을 경우 반드시 인코딩/디코딩 과정을 거쳐야 한다.

urllib ?

  HTTP는 굉장히 많이 쓰이기 때문에 소켓을 다루고 웹 페이지를 불러오는 라이브러리가 있음

  소켓의 모든 기능을 가진 편리한 파이썬 라이브러리
  소켓으로 10줄인 코드를 urllib을 사용하여 4줄안에 끝낼 수 있음.

  urllib은 연결을 만들고 GET요청 인코딩하여 을 전송하고 새로운 줄을 보내거나 데이터를 받거나
  헤더를 처리하는 등 모든 걸 다합니다. (응답도 가져온다.)
  그리고 객체 형태로 반환합니다.(파일 핸들처럼)
  * 헤더는 urlopen에서 암묵적으로 처리하므로 출력되지 않습니다.

  예)
    import urllib.request, urllib.parse, urllib.error

    fhand = urllib.request.urlopen('http://www.dr-chuck.com/page1.htm')
    for line in fhand:
      print(line.decode().strip())


  * 디코딩은 자동이 아니므로 디코딩은 수동으로 해줘야함
    (파이썬 3 이상은 문자열들이 바이트(ASCII코드)로 들어오면 디코딩 해줘야한다.)

  이렇게 좋은 게 있으면 라이브러리에 넣고 써야죠!

크롤러

  웹 페이지를 수집. 구글도 파이썬을 사용하고 있음.
  우리도 파이썬을 이용하여 만들어보자!

웹 스크래핑(HTML 파싱, 웹 스파이더링 이라고도 한다.)

  웹 스파이더링이라고도 한다. 웹페이지를 받아 링크를 추출하고 추출한 링크들을 차례로
  처리하는 작업이다. 인터넷에 있는 대부분의 웹페이지가 연결되는 페이지를 찾아낼 수 있다.

  * 수집된 데이터는 다양한 용도로 사용이 가능하다.

  • 이용약관을 위배하지 않도록 유의

  모든 웹사이트가 여러분의 로봇에 의해 스크래핑 당하고 싶지 않아한다.
  주소를 차단해버릴 수도 있다. 어떤 사이트가 스크래핑을 허용하는지 알고 있어야 한다.
  (크롤링을 합법으로 처리하는 사이트가 어디인지 알아야 한다.)

Beautiful Soup

  HTML문서를 주면 태그를 알려줄게!
  HTML과 XML을 파싱하는 데에 사용되는 파이썬 라이브러리이다.

  BeautifulSoup는 bytes, UTF-8 모두 지원한다.
  덜 닫힌 앵커태그도 알아서 분석하여 지원한다. ( 똑똑함 )

* TCP/IP는 애플리케이션 사이에 파이프/소켓을 구축
* 애플리케이션 프로토콜로 이 파이프를 사용
* HyperText Transfer Protocol(HTTP)는 간단하지만 굉장히
  강력한 프로토콜
* 파이썬은 소켓, HTTP, and HTML 파싱을 충실히 지원

  UTF-8 도 다룰 수 있고, 유니코드도 다룰 수 있다.

  파이썬이 지원하지 않는 인증서를 사용할 경우 가져오지 못한다.

뷰티풀 수프 4 한국어문서

  https://cryptosan.github.io/pythondocuments/documents/beautifulsoup4/

----------------------------------------------------------------------

소켓

  소켓이라는 개념은 하나의 애플리케이션 프로세스로부터 다른 어플리케이션 프로세스로
  데이터를 보내는 것이다.

직렬화? 역직렬화?

  파이썬의 딕셔너리 같은 내부 표현 형식으로부터 데이터를 가져와야
  와이어로 보내는 것을 직렬화라고 한다.
  특정 언어로 된 데이터 불러와서 전송할 준비를 마친 뒤 전송을 실행하고
  그것을 받아서 다시 데이터로 변환하는 것이다. ()대상 시스템의 내부 데이터 표현과 상관없이)

  즉 내부적 표현 직렬 표현 혹은 와이어 표현으로 보내는 것이다.
  언어와 상관없이 쓸 수 있게(다른 프로그래밍 언어에서는 그 언어 내에서 사용 가능한 구조로 만들기 위해 역직렬화한다.)

  ex) 파이썬 딕셔너리 -> 직렬화-> 와이어 (XML 또는 JSON) -> 역직렬화 -> 자바 HashMap

XML을 사용하는 와이어 프로토콜(직렬화와 역직렬화가 이루어진다.)

* JSON은 더 간단하고 쉽지만 XML보다는 정교하거나 상세하지 못하다.
  우리가 실행하는 대부분, 특정형식의 API 등은 JSON이 흔히 이용된다.
  그러나 여전히 XML은 문서와 관련하여 사용된다.

XML ( Marking up data to send across the network...)

  예)  워드 문서의 XML 버젼. 확장자명이 docx

* 데이터를 마크업하는 방식에는 XML과 JSON이 있다.

XML? ( Extensible Markup Language)

  1990년대 HTML 출현 - HTML은 앵커태그 < > 를 표현의 방식으로 이용하게 되었다.
  XML은 태그와 < > 가 있다는 점에서 HTML과 매우 유사하지만, 다른 점은
  태그의 명칭을 원하는 대로 정할 수 있다는 것이다.

  XML은 eXtensible Markup Language의 약자로, 다음과 같은 계층 구조로 이루어져있습니다.
  HTML과 비슷하지만 원하는 이름의 태그를 만들 수 있다는 특징이 있고,
  HTML보다 문법 오류를 더 엄격하게 다룹니다. (트리구조이다.)

  * XML에서의 문법오류는 HTML보다 더 엄격하게 다루어진다.
    ex) <phone type="intl">+1 734 303 4456</phone> 에서
        type은 키, "intl"는 값에 해당된다.

        스스로 닫는 태그가 있다. />. 끝 태그가 없음.
        모든 정보가 속성에 기록되어 있어서 추가로 끝 태그를 위한 빈 텍스트
        자리가 필요 없다.

        시작 태그, 끝 태그, 속성 그리고 스스로 닫는 태 이것들이 XML의 기본적인 요소이다.
        일반적으로 공백은 신경 쓰지 않지만, 텍스트 지점에서는 중요하다.

  * 부모 노드와 자식 노드가 존재하고, 계층 구조로 되어있는 것이 특징
    부모 자식 관계를 가진 트리 구조.
    텍스트 노드는 하나밖에 가질 수 없다.

  * 하나의 단순 노드는 하나의 텍스트 요소밖에 가지지 못한다.

  * XML을 하나의 경로라고도 생각할 수 있다.

  '''로 묶인 문자열을 사용.

파이썬 XML 라이브러리 사용법

  예)

    import xml.etree.ElementTree as ET

    data = '''

      HTML 태그 부분

      '''
      tree = ET.fromstring(data)

  tree.find('속성').text 하면 해당 속성의 그 문자 정보를 받는다. 텍스트 노드를 불러온다.
  tree.find('속성').get 은 해당 속성의 내용을 요청하는 것이다. ex) <email hide="yes"/> 면 yes를 가져온다.
  hou = tree.findall('users/user') - findall 메소드를 이용하여 users 아래의 user 태그를 불러왔다.
                                     해당하는 리스트를 리턴하므로 len(hou) 찍어보면 매치된 태그리스트의 개수가 나온다.


* 태그가 있으면 그 안의 문자를 불러올 수 있고, 그 태그의 속성을 불러올 수도 있다.

XML Schema

  하나의 언어로, 특정 XML 문서가 어떤 조건이나 형식에 부합하는지 확인하는 것이다.
  XML을 이용해 정보를 교환하고 둘 중 하나가 작동하지 않는다면

  어떤의미에서는 RFC랑 비슷하지, XML 스키마는 그 범위가 두 응용프로그램 사이인 점에서 다르다.
  XML Schema 계약을 가지고 둘 중 어떤것이 잘못되었는지 판단하는 검증 작업을 한다. (Validation)

  * 특정 스키마를 이용하는 소프트 웨어를 검증기라고 한다.

  스키마 계약은 그 자체로 하나의 XML이며 xs:complexType을 지닌 XML의 한 종류이다.
  XML이 특정 형태를 가지도록 다듬어준다.

XSD XML 스키마 (W3C spec)

 - World Wide Web Consortium (W3C) 버전에 집중된 스키마.
 - “W3C 스키마”라고 불리는 이유는 “스키마”가 포괄적인
 표현이기 때문
 - 흔히 XSD 라 불리는 이유는 파일 확장명이 .xsd 이기 때문
 - 최근 가장 많이 쓰임

* XML은 한 서버에서 오고 네트워크의 한 부분에서 이 XML을 얻을 수 있다.

XSD 구조

  - xs:element
  - xs:sequence
  - xs:complexType
    이렇게 구성되어 있음.

  * XML 구조

    <person>
      <lastname>Severance</lastname>
      <age>17</age>
      <dateborn>2001-04-17</dateborn>
    </person>

  * 위 XML 코드와 대응되는 XSD 구조

      <xs:complexType name=”person”>
        <xs:sequence>
        <xs:element name="lastname" type="xs:string"/>
        <xs:element name="age" type="xs:integer"/>
        <xs:element name="dateborn" type="xs:date"/>
        </xs:sequence>
      </xs:complexType>

XSD 제한

  * XSD 제한

     <xs:element name="person">
      <xs:complexType>
       <xs:sequence>
        <xs:element name="full_name" type="xs:string"
        minOccurs="1" maxOccurs="1" />
        <xs:element name="child_name" type="xs:string"
        minOccurs="0" maxOccurs="10" />
       </xs:sequence>
      </xs:complexType>
     </xs:element>

 * 위 XSD 제한과 비교되는 XML 코드

    <person>
      <full_name>Tove Refsnes</full_name>
      <child_name>Hege</child_name>
      <child_name>Stale</child_name>
      <child_name>Jim</child_name>
      <child_name>Borge</child_name>
    </person>

XSD 데이터 타입

  <xs:element name="customer" type="xs:string"/>
  <xs:element name="start" type="xs:date"/>
  <xs:element name="startdate" type="xs:dateTime"/>
  <xs:element name="prize" type="xs:decimal"/>
  <xs:element name="weeks" type="xs:integer"/>

  <customer>John Smith</customer>
  <start>2002-09-24</start>
  <startdate>2002-05-30T09:30:10Z</startdate>
  <prize>999.50</prize>
  <weeks>30</weeks>

  서버가 세계에 퍼져있다는
  가정 하에, 흔히 시간을
  UTC/GMT 로 표현한다 (그리니치 평균시. 런던 기점, 웰링턴 종점으로 하는 협정 세계시)

ISO 8601 날짜/시간 형식

  2002-05-30T09:30:10Z

  앞에서부터 순서대로 년-월-일 , T(Time)시간 , 시간대 - 주로 현지 시간대가 아닌 UTC / GMT로 명시

------------------------------------------------------

JavaScript Object Notation(JSON)

  더글라스 크락포드가 JSON을 '발견'(원래 자바스크립트에 있었음)
  또다른 직렬화 형식인 JSON(JavaScript Object Notation)
  XML보다 많이 사용.
  * XML은 체계적이고 기능이 풍부하다는 장점이 있다.
  JSON은 시스템에 추출하여 두 시스템 사이에서 간단하게 이동하게 해준다.

* 자바스크립트는 좋은 언어이다

  JSON은 파이썬에서 리스트와 딕셔너리가 합쳐진 형태로 굉장히 비슷하기 때문에
  데이터를 읽어온 후 딕셔너리로 접근할 수 있다.
  파이썬의 딕셔너리와 매우 비슷하다.

  JSON은 XML보다 더 자주 사용되는 데이터 포맷이다.

  JSON을 선호하는 이유는 주고받을 형식을 정할 때 더 만들기 쉽고 읽기 쉽다는 것이다.

  XML이 속성 이름과 속성 값, 항목의 내용(text)을 구분해서 각각 표시한다면,
  JSON은 속성의 값도, text도 '값'으로 동일하게 보는 것 같다.

  XML의 복잡함이 필요 없는 상황에서는 JSON이 더 낫다고 볼 수 있다.

  사용하려면 파이썬에 내장되어있는 json 라이브러리를 불러와야 한다.  ( import json )

  * 사용할 때는 JSON은 인터넷으로 부터 읽고 디코딩한 것을 사용한다.

  JSON 라이브러리의 json.loads()는 문자열을 불러오고 파싱하여 하나의 구조체로 만든다.
  문법 오류를 범하지 않고 아무런 문제가 없다면 하나의 구조화된 표현을 얻게 된다.
  주어진 것을 파싱하고 JSON 문법으로부터 파이썬 문법인 리스트로 변환한다. ( 리스트라서 len함수 사용 가능 )

  XML과 JSON의 다른 점은 JSON 키와 값을 가진 딕셔너리가 된다는 것이다.
  (딕셔너리를 포함한 딕셔너리를 추출할 수도 있다. ex) info=json.loads(data) print (info["email"]["hide"])
  XML에서는 속성이라는 개념이 외부 태그에 있지만, JSON에서는 이름이 없어서 우리가 원하는 것을 딕셔너리에서 직접 찾아야 한다.

  * 사람들이 JSON을 선호하는 이유는 JSON을 읽을때 자바스크립트로부터 온 문법이지만
  파이썬의 문법과 매우 유사하기 떄문에 JSON 객체를 그대로 파이썬 딕셔너리로 변환하는 것때문이다.

  자바스크립트에서는 객체의 리스트겠지만, 파이썬에서는 딕셔너리의 리스트이다.
  JSON에서는 find나 findall 같은 것을 사용하지 않고 구조에 바로 접근할 수 있다.
  빠르게 정보 추출 가능.

  XML은 항목에 값이 없을 때 None으로 출력이 되었는데,
  JSON은 값이 없으면, 공백으로 출력한다.

Hashing?

  해싱은 하나의 문자열을 원래의 것을 상징하는 더 짧은 길이의 값이나 키로 변환하는 것이다.
  짧은 해시 키를 사용하여 항목을 찾으면 원래의 값을 이용하여 찾는 것보다 더 빠르기 때문에, 해싱은 데이터베이스 내의 항목들을 색인하고 검색하는데 사용된다.

  데이터베이스 검색 수법은 일치하는 것이 먼저 발견될 때까지 각 이름들을 글자단위로 확인하기 시작해야만 한다. 그러나, 만약 이름들 각각이 해시 된다면,
  각 이름별로 4자리의 고유한 키 (자릿수는 데이터베이스 내에 들어있는 이름의 수에 따라 다르다)를 생성하는 것이 가능해진다. 예를 들면 다음과 같다.

  7864 Abernathy, Sara
  9802 Epperdingle, Roscoe
  1990 Moore, Wilfred
  8822 Smith, David
  (기타 등등)

-----------------------------------------

SOA (Service Oriented Approach) - 서비스 지향 접근 (방법)

  Service Oriented Approach

  서비스 지향 아키텍처(Service Oriented Architecture, 약칭 SOA 「에스오에이」혹은 「소아」로 발음)란
  대규모 컴퓨터 시스템을 구축할 때의 개념으로 업무상에 일 처리에 해당하는 소프트웨어 기능을
  서비스로 판단하여 그 서비스를 네트워크상에 연동하여 시스템 전체를 구축해 나가는 방법론이다.

  서비스 계층을 연결하고 싶은 애플리케이션에 적용하는 것으로
  정보를 다른 곳에서도 사용할 수 있는 형식으로 불러내는 것이다.
  서비스 지향 접근은 기존에 있던 소프트웨어에서 잘 작동하며 획일화된 기존 애플리케이션을
  삭제할 필요도 없다. 서비스 계층, 즉 서비스레이어에 연결할 때 다른 사용자에게 영향을 주지 않는다.
  새로운 애플리케이션이 추가될 때 같은 방식으로 시스템을 확장시킨다.
  시스템간 호환 가능한 구조로 발전한다. 이러한 경우 정보 공유의 기회를 나라와 나라간에도 가질 수 있다.

  예) 연구 커뮤니티간의 실험 공유 등등

    흩어진 자원들이 서비스의 흐름과 협력함으로써 실험을 만들어간다.
    작업의 흐름과 문의 사항들 웹서비스 프로토콜을 이용해 엮어서 자원을 제어한다.
    myGrid(연구용 프로그램)를 통해 생성된 작업 흐름은 실험의 과학적인 과정을 표현하고
    자신과 같은 새로운 실험을 수행하는 과학자들에게 풍부한 자원이 된다. myGrid(API) 사회를 통해서.

  많은 교육과 연구 서비스 이미 서비스 지향 접근을 이루고 있다.
  기업 사회와 소프트웨어 개발자들을 선두로 달리고 있다.
  현대 사회에서 교육과 연구 사회에 서비스 지향 접근이 필요함이 증명되고 있다.

  * 설계도와 참고사항을 제공함으로서 공유된 어휘와 교육과 연구에 대한 여러 방식을 발전시킨다.(ex) 웹 프레임워크 공식설명서 홈페이지 등등)

------------------------------------------

API (Application Program Interface)

  API는 하나의 계약으로, 기능들을 제공한다.
  어떤 것을 하면 어떤 식으로 정보를 주겠다.
  규칙을 정하기도 하 URL을 살펴봐서 XML인지 JSON인지 알아내기도 한다.
  우리가 직접 읽고 또 이해해야 하는 것들이다.

URL 인코딩 규칙들? (URL에 쓰이는 특수 문자들과 그 의미)

  %2C - 쉼표 ( %는 16진수로 인코드된 문자들을 표시하기 위한 표시 문자) * 헥스코드의 2C는 쉼표를 의미 그냥 16진수. (0~9, a~f로 이루어진 숫자)
  + - 공백
  ? - 키
  = - 앞에는 키, 뒤에오면 값 (ex) ?address=hou)
  & - 파라미터 구분자. query 문자열에서 이름=값으로 나타나는 파라미터 쌍을 구분하기 위해 사용된다.
  # - 웹 페이지에서 어떠한 지점을 표시할 때 사용
  : - 프로토콜 구분자 (리소스 요청시 사용한 애플리케이션 계층의 프로토콜 표시)

* API 관련된 URL을 방문하게 되면(브라우저에 URL 그대로 쳐보면) JSON 문서를 돌려받게 된다.
  즉 API와 관련된 키와 값의 쌍으로 이루어진 객체를 반환받는다.
  요점은 JSON을 읽을 수 있는 프로그램을 짜느냐 이다.

API 보안과 비율 제한

  • API를 실행하기 위한 계산 자원은 “무료”가 아님
  • API를 통해 제공된 데이터는 대체로 매우 가치가 높음
  • 데이터의 제공자는 하루 요청량을 제한하여서 API 의 “키”를 요구하거나, 사용료를 부과하기도 함
  • 발전을 거치면서 여러 규칙들이 바뀌기도 함

* SOAP (Simple Object Access Protocol)

  일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다.
  SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.

  SOAP는 'Simple Object Access Protocol'의 약어이지만, 버전 1.2부터는 그 의미가 퇴색되었다.
  2003년 6월 24일, W3C에서 버전 1.2 권고안이 나왔으며, 서비스 지향 아키텍처(SOA:Service-oriented architecture)와 그 의미가 종종 혼용된다.
  그러나 엄연히 SOAP와 SOA는 다르다. SOAP는 데이브 위너(Deabe Winer), 돈 박스(Don Box), 밥 액킨슨(Bob Atkinson) 그리고
  모슨 얼 고세인(Mohsen Al-Ghosein) 등이 1998년 액킨슨과 얼 고세인이 그 당시 일하고 있던 마이크로소프트의 후원으로
  객체 접근 규약(Object Access Protocol)로서 처음으로 디자인했다. SOAP의 표준화 작업은 현재 W3C의 XML protocol Working Group이 관리하고 있다.

  SOAP은 XML을 근간으로 헤더와 바디를 조합하는 디자인 패턴으로 설계되어 있다.
  「헤더」는 선택사항으로 반복이나 보안 및 트랜잭션을 정보로 하는 메타 정보를 가지고 있다.
  「바디」부분은 주요한 정보인 정보를 가지고 있다.

----------------------------------------------------------

이제 객체만 하면 파이썬 끝.
