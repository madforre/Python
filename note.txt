소켓 - 통신

    소켓은 다른 소켓과 서로 데이터를 주고받을 수 있다.

    프로그램마다 소켓이 들어있음.

    즉 프로그램들끼리 통신이 가능함.

    가장 큰 특징은, 다른 컴퓨터와 네트워크가 쭉쭉 연결되어있으면
    다른 컴퓨터에서 실행한 프로그램의 소켓과도 통신이 가능하게 해준다는 것.

    소켓은 유닉스,리눅스 기준에서 파일 그 자체이다.
    파일을 생성해서 필요한 정보를 저장해놓고 사용한다.

    ls -al 치면 d가 디렉토리 s가 소켓을 뜻함.

    소켓은 주소정보를 담고 있다.
    한 컴퓨터 내에서 현재 돌고 있는 프로세스를 구분해준다.

    * 소켓으로 통신을 하려면 어떤 프로세스인지 알고 찾아가야 한다.

        그걸 알려주는 것이 포트번호.

        또 필요한 것은 ip주소.

        즉 소켓은 ip주소와 포트번호, 이 두가지 정보를 가지고 있다.

    데이터를 담아서 어디든 보낼 수 있음.

TCP / UDP 프로토콜

    TCP - 연결형 통신 ( 소켓끼리 연결을 하고, 한번 연결하면 연결한 상태를 유지한다. )

        중간에 데이터가 빠진 부분이 있으면 빠진걸 다시 보내줌. 즉 신뢰성 있는 프로토콜이다.

        three way handshake 간다?->응 와->감

            * 중요한 파일전송 (중간에 하나라도 빠지면 안되는 것들 전송할 때 쓰인다.)에 쓰인다.

    UDP - 비연결형 통신 ( 소켓이 있으면 데이터를 한번보낸다. 그러면 끝. 잘못받았는지 받았는지는 관심 없음.)

        장점은 속도가 빠르다. 하지만 잘 받았는지 안받았는지 신경 안쓴다.
        데이터를 담아서 그냥 보내면 끝이다.

            * 스트리밍 , 전화에 쓰인다. ( 데이터가 중간에 유실되더라도 큰 지장이 없음. )


socket 메소드 안의 메소드들 connect, send, recv 등을 사용하여 소켓 통신하도록 프로그래밍.

connect는 클라이언트. 서버에서는 소켓을 만들어서 accept를 해야함

사용하려면 import socket해주자. 기본 모듈임.


서버 측

    bind -> listen -> accept

클라이언트 측



패킷?

    패킷(packet)은 사전적인 의미로는 '한 다발, 한 묶음'을 뜻하는 말로 통신, 네트워크에서는 한 번에 전송하는 정보의 단위를 일컫습니다.

쓰래드

    하나의 프로세스에서 두가지 작업을 동시에 하는 것이다. 여러개의 처리를 해주는 것이다.


함수 정의

    def 로 정의하도록 한다.

---------------------------------------------------------

라즈베리 파이 - 단일 보드 컴퓨터

CPU(Central Processing Unit) - 머리, 두뇌
      현대 CPU는 1960년대와 달리 축전기, 저항기, 트랜지스터 회로가
      극소화 되어있다. 광학적인 방법으로 더 작고 더 많이 회로를 새겨놓았음.
      몇백만 개를 한 개로 만들 수 있는 것이다.
      프로그램을 실행한다. CPU는 항상 다음에 무엇을 하지? 라고 물어본다.
      처리능력이 매우 뛰어나다.

메인 메모리 - 명령이 저장되어 있음.
             메인메모리는 CPU가 필요로하는 명령을 제공한다.
             CPU에게 명령을 전달한다.
             빠르게 작동하며 프로그램을 저장한다.
             속도는 매우 빠르지만 컴퓨터를 종료하면 사라지는 휘발성 메모리.

CPU가 새로운 명령이 필요하면 메인 메모리한테 어디에 명령이 있는지 물어본다.
소프트웨어를 통해 CPU를 제어한다.

마더보드 - 모든 부품을 연결한다. (메모리, CPU, 하드 드라이브 등등 끼워넣어서 사용한다.)
            모든 부품을 연결해줌.

보조 기억장치 - ex) 하드드라이브 SSD HDD, USB
               영구적으로 데이터를 저장한다.
               메인메모리와 다른 점?
               메인 메모리는 매우 빠르다.
               하지만 전원을 끄면 정보가 사라진다.
               워드 파일, 텍스트 파일등을 기록해 두려면 오래된 곳에 저장해서 보관해야 한다.
               보조 저장소가 그 역할을 한다. 전원이 꺼져도 영구적으로 메모리를 저장한다.

우리 프로그래머들은 메인 메모리에 서 있다.
코드를 작성하면 메인 메모리가 CPU에 전달하여 명령을 처리한다.

각각의 관계

  CPU는 계속해서 다음에 무엇을 할지 물어 봅니다.
  이것에 대한 답변은 사람이 하며, 답변들의 목록이나 순차적으로 진행되어야 할 사항들을
  파이썬 언어로 작성한 뒤 보조 기억장치에 저장합니다. CPU의 질문에 답변을 해야 하는 순간이 오면
  메인 메모리에 해당 내용을 로드 합니다. 이 과정에서 2진수로 만들어져 있는 기계어로 마법처럼
  변환이 되며 이는 컴퓨터가 이해할 수 있는 언어로 전달 되게 됩니다.
  그 후 내부적으로는 1초에 수십억번(CPU에 성능에 따라 달라집니다)에 걸쳐
  질문과 답변이 이루어 지게 됩니다.

파이썬은 Monty Python's Flying이라는 서커스에서 영감을 받아 지은 이름이다.
귀도 반 로섬이 20년전에 만듦. 강력하고 다가가기 쉬운, 재밌는 프로그래밍 언어를
만들고 싶었던 귀도 반 로섬의 마음을 잘 보여주는 네이밍이다.
배우기 쉽고 간결하고 강력하다.

------------------------------------------------

파이썬의 예약어

Reserved Words - 예약어

  일종의 약속과 같다.

  False, class, return, is, finally, None, if, for, lambda, continue
  True, def, from, while, nonlocal, and, del, global, not, with, as,
  elif, try, or, yield, assert, else, import, pass, break, excpet,
  in, raise

  예약어는 약속된 단어이기 때문에 변수의 이름이나 식별자로 사용할 수 없습니다.

Sentences or Lines - 문장/줄

  x = 2       Assignment statement 대입문
  x = x + 2   Assignment with expression ( 대입문 + 표현식 )
  print(x)    Print statement ( 출력문 )

  변수 연산자 상수 함수로 구성되어있다.

프로그래밍 문단

  Python Scripts - 스크립트

    대부분의 프로그램은 길기 떄문에 파일에 코드를 적고
    파이썬이 파일에 있는 명령을 실행한다.
    파일 이름에 .py를 붙여 파이썬을 썼다는 것을 표시
    파이썬에 스크립트를 주는 것과 같음.
    코드가 길어질 경우에는 스크립트 방식이 효과적이다.
    파일을 보조 기억장치에 저장 한 뒤 한 번에 실행시켜 처리한다.

  Interactive - 상호대화식

    파이썬에 한 줄을 입력하면 바로 반응.
    코드가 생각한 대로 작동하는지 테스트하기 좋다.
    3~4줄의 코드를 실험하기 좋음.
    커맨드라인에서 한줄씩 실행하는 방법은 상호대화식이라고 한다.
    즉각적이 ㄴ결과 호가인에 유리하다.

프로그램 단계 / 흐름

- 순차문 : 레시피나 설명문과 같이 진행 순서를 가짐. 순서대로 진행됨
          (Sequential Steps)

- 조건문 : 건너뛸 수 있음
          (Conditional Steps)

- 반복문 : 반복되어 실행
          (Repeated Steps)

* 들여쓰기가 없는 부분은 순차적으로 실행된다.

---------------------------------

Constants - 상수 (변하지 않는 고정 값)

Variables - 변수 (메모리 안의 이름이 지정된 장소에 데이터를 저장할 수 있음)
            값을 원하는대로 변경할 수 있다.

Python Variable Name Rules

  파이썬과 대화할 때 밑줄을 쓰기 떄문에 되도록 변수 이름을 밑줄로 시작하지 않습니다.
  첫 글자 다음으로 문자, 숫자, 밑줄이 올 수 있습니다.

  * 대소문자로 변수를 구별하지 말 것!!! 정말 안좋은 생각이다. 숫자로 시작해도 안좋다.
    #이나 .으로 시작해도 안좋음.
    문자로 시작하고 다음에 문자, 숫자, 밑줄 변수 이름을 정합니다.

Mnemonic Variable Names (연상기호, 기억을 돕는 변수 이름)

  변수 이름은 프로그래머 마음대로 아무 이름으로 지정해도 된다. - 단, 모범 기준을 따르자.
  변수 값과 연관 지어 변수 이름을 지정 (연상 기호)
  단점 : 변수 이름이 키워드인 것 같아 보일 수 있기 때문에 초급자는 헷갈릴 수 있음.

Sentences or Lines

  Variable / Operator / Constant / Reserved Word로 구성되어 있음.

-------------------------------------

Numeric Expressions - 숫자 표현식(연산자)

  + Addition
  - subtraction
  * Multiplication
  / Division
  ** Power
  % Remainder (It's also called the modulo operator.)

--------------------------------------

Order of Evaluation (값 구하는 순서, 연산자 순위)

  우선순위

  1. 괄호먼저. (Parenthesis)
  2. 그다음 거듭제곱이 우선 (Power)
  3. 그다음 곱하기 나누기 (Multiplication, Division)
  4. 더하기, 빼기 (Addition, Subtraction)

  계산시 Left to Right. 왼쪽에서 오른쪽 법칙 적용.

-------------------------------------

연산자는 똑똑합니다.
값 변수 상수인지에 따라 다른 연산을 합니다.

Traceback은 작동하다가 혼란스러운 부분이 있어 더이상 실행시키지 않는 것입니다.

파이썬은 타입에 민감합니다.

파이썬은 내재된 함수 type을 사용하여 타입을 확인 가능하다.

type()

--------------------------------------

int 정수

float 부동 소수점 수(파이썬에서 숫자를 표현하는 방법이다.)

상수는 int이거나 float일 수 있다.

* 내재된 함수 int나 float를 사용해서 타입을 바꿀 수도 있다.

파이썬 3에서의 정수 나눗셈은 항상 부동 소수점 수를 줍니다.
예측 가능하고, 계산기처럼 작동합니다.

* 파이썬 3.0에서 나눗셈은 부동 소수점 수를 줍니다!

---------------------------------------

고정 소수점(Fixed-point arithmetic) 형식

  이는 소수점의 위치가 특정 위치에 고정되어 있다고 가정하고 실수를 표현하는 방식입니다.
  예를 들어 1230과 1230000이라는 수가 있을 때 소수점의 위치가 1000이라고 하면
  각각의 수는 1.23과 1230을 나타내게 되는 것입니다.

부동 소수점(Floating Point) 형식

  이는 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적어내어
  실수를 표현하는 방식으로 유효숫자를 나타내는 가수부와 소수점의 위치를 나타내는
  지수부로 나누어 표현합니다. 고정 소수점 방식보다 매우 큰 수와 작은 수등
  넓은 범위의 수를 나타낼 수 있는 것이 큰 특징입니다.

  고정 소수점 표현 : 123.456
  부동 소수점 표현 : 0.123456×10³ = 가수×지수

이런게 있다는 걸로 만 알고 있자..
----------------------------------------

String Conversions(문자열 변환)

  int나 float 함수를 사용하여 타입을 바꿀 수 있다.

---------------------------------------

User Input (사용자 입력)

  input() 함수로 멈추고 사용자의 입력값을 받을 수 있음

  input() 함수는 문자열을 반환.

--------------------------------------

주석

파이썬은 # 다음 모든 내용을 무시

-------------------------------------

Indentation (들여쓰기)

  파이썬에서는 들여쓰기가 잘못되면 에러가 뜹니다.
  고로 중요하다.
  띄어쓰기 4번, 스페이스 4번이 들여쓰기 기준이다.

  파이썬은 탭과 들여쓰기를 꼭 구분해줘야 한다.
  에디터의 설정이 탭이 스페이스 4번이 아닐 경우 탭을쓰면 들여쓰기 에러가 뜬다.
  문법 에러 발생. (설정에서 탭의 기능 변경하기에서 스페이스 설정을 해주어야 한다.)

  * 들여쓰기를 통해 어디까지가 if문인지 정할 수 있다.

  블록들은 콜론을 시작으로 내어쓰기가 된 줄을 포함하지 않은 곳 까지 이어진다.

---------------------------------------

Two-way Decisions

  If와 else를 사용한 두 갈래길 조건문

------------------------------------------

들여쓰기가 복잡하다고 생각할 수 있지만, 파이썬은 우아한 언어이다.

* 조건문이 참일 경우 실행할 코드는 들여쓰기를 해야한다.
* 조건문 후에 : (콜론) 을 찍어야 한다.

------------------------------------------

Multi-way Decisions(다중 분기)

  elif라는 예약어를 이용한다.

    if, elif, else 중 하나만 실행된다.
    중요한 것은 질문을 순서에 따라 확인하는 것이다.
    * 첫 번째 질문이 거짓일 때까지 두 번째 질문을 확인하지 않는다.
    else가 없어도 된다. (아무것도 실행 안될 수 있다.)

----------------------------------------------

try / except

  파이썬은 복구하고 싶은 부분에 trackback 에러를 띄우는 경향이 있다.

  에러가 나서 프로그램이 중단될 부분을 안다면 중단되는 것을 원치 않을 것이다.
  프로그래머는 사용자의 입력 값을 보고 코드에서 중단될 수 있는 부분이 어디인지를
  예상할 수 있어야 합니다. 그리고 해결을 할 줄 알아야 합니다.
  이 때 try 와 except를 이용해서 합니다.

  * try부분을 실행하되, 실패하면 except 부분을 실행된다.
    뭔가가 잘못됐을 때 except 블록이 나서서 에러가 떴을 때 진행해야
    할 일을 합니다.

    남용하지 않도록 조심하도록 하자.
    try 블록에 한줄 이상을 넣어 예외가 발생해 실행이 중단되면
    다시 try블록으로 돌아오지 않으므로 주의

    즉 try 블록이 실행되고 에러를 만나면 except 블록으로 이동하는 것이다.

  * 중단될 것 같은 한 줄만 try 블록에 놓는 것이 좋다.

  try / except 와 if / else 를 적절히 섞어 쓸 수도 있다.

  * 사용자가 예외를 발생시킬 만한 값을 입력하면 try / except로 잡을 수 있다!
---------------------------------------------------

들여쓰기는 블록의 시작과 끝을 표시하는 중요한 역할을 한다는 것도 다시한번 기억하자!

-----------------------------------------------------

* 프로그래밍 에서 중요한 것은 같은 작업을 반복하지 않는 것이다.

함수는 하나의 박스라고 생각하시면 됩니다. 프로그래밍에서 함수를 사용하는 이유는
반복적으로 실행되어야하는 코드의 묶음을 프로그래머가 기억하기 쉬운 이름으로 저장하여
반복적으로 호출하고 싶을 때 함수를 사용합니다.

* 재사용 가능한 코드.

def - 정의된 함수를 뜻한다. 역시 콜론으로 끝나고 들여쓰기 된 블럭이 있다.
      내어쓰면 함수가 끝난다.

      실제로 실행되는 코드가 아닌 코드를 기억하는 부분이다.
      즉 저장 단계이다.

      * Stored (and reused) Steps

      def 구문으로 파이썬을 확장시킨 셈.(내장 함수 뿐만 아니라 사용자 정의 함수를 추가한 셈)

* 함수는 반복적으로 호출해야 하는 코드의 묶음을 하나의 블럭으로 만들어 이름을 붙여
  재사용률을 높인 "코드의 묶음"입니다.

------------------------------------------------------

내장함수  max() 문자열의 아스키코드 중 큰걸 찾아준다.
         min() 문자열의 아스키코드 중 작은걸 찾아준다.
         input( ) # ( 괄호 ) 안의 사용자 입력값을 받는 함수
         print("Hello World") # ( 괄호 ) 안의 내용을 출력하는 함수
         float( ) # ( 괄호 ) 안의 값을 float로 변환하는 함수
         int( ) # ( 괄호 ) 안의 값을 int로 변환하는 함수

------------------------------------------------------

자료형 변환

  정수형과 실수형을 표현식에 동시에 사용할 때
  정수는 암시적으로 실수형으로 변환된다.

문자열 변환

  int()와 float()를 문자열에서 정수형으로 변환할 때도 사용할 수 있음

  문자열이 숫자를 포함하지 않으면 에러

------------------------------------------------------

def은 정의하는 것이고
호출(invoke)은 재사용하는 것이다.

return - 함수실행 종료, 함수의 결과값 반환

값을 반환하는 함수를 fruitful 이라고 하는데, 무엇을 생산하기 때문이다.
  fruitful(유익한, 다산의, 비옥한, 열매가 잘 열리는)

되도록 함수는 바로 출력하기보다는 값을 반환하는게 좋다.
함수가 출력하도록 하면 코드가 볼품없어진다.

인자는 함수를 호출할때 전달하는 값을 말하고
매개변수는 함수가 정의된 곳에서 변수처럼 사용하는 것을 말한다.

반환 값을 가질 필요가 없다는 것?
반환 값이 없는 함수는 Void 함수라고 부른다.
* Void (non-fruitful) Functions

--------------------------------------------------------

Repeated Steps - while 루프

* 루프의 종료를 위한 의도적 행위가 없으면 무한히 반복되는루프
  while 루프는 조건문이 거짓이 되기 전까지 계속 실행되기 때문에
  불확정 루프라고 불린다.

  while 반복문에서
    iteration variable 에 아무것도 안하면 무한 루프에 빠질 수 있다.

  break

    break구문을 만나면 그 루프는 끝난다.(위에서 무슨 일이 있었던)
    break는 루프 블럭의 다음으로 이동시킨다.
    break는 루프에서 나가라고 한다.

  continue

    이번 회차의 실행을 멈추고 루프의 제일 위로 올라가서 루프를 계속 실행.

  Break 구문을 가진 Infinite Loops?

    어떤 순간에 빠져나올 수 있기 때문에 무한루프가 아니다.
    루프를 설계하는 유명한 방법 중 하나이다.
    즉 Indefinite Loops 라는 것.(불확정 루프)

  Indefinite Loops

    종료 조건이 복잡해지거나 코드가 길어지고, 코드가 정말 종료될 수 있는지
    불분명해집니다.

  while 루프를 이용해 많은 것을 할 수 있지만
  대부분의 반복문을 만들기 위해 유한 루프라는 것을 사용하게 됩니다.
  (Definite Loops)

-----------------------------------------------------------

for 루프

  유한개의 항목을 가지고 있고 인간의 의도적 행위 없이 주어진 항목들을
  모두 순회하게 되면 종료되는 루프

Definite Loops

    어떤 집합의 원소들에 대해 반복문을 실행하는 것입니다.

파이썬의 for 문은 좀 독특한 편이다.

ex)
  for i in [5, 4, 3, 2, 1] :
    print(i)
  print('Blastoff!')

변수가 헷갈리지 않도록 반복변수는 단수로 설정하자!
리스트는 복수형 변수로 쓰도록 하자!

for 루프는 while 루프에서라면 개별적인 구문이 했어야 하는 일을
한 번에 하고 있다. 먼저 루프를 몇번 실행할지를 결정한다.

Done? no! -> 실행 -> Done? -> yes! -> 끝

* for루프가 i를 설정(i는 조건에 의해 계속 변한다.)하고 코드를 실행한다.

------------------------------------------------------------------

컴퓨터와 인간의 문제 처리 방식이 다르다는 것은 반복문 이해에 가장 중요한 부분이다.

------------------------------------------------------------

Loop Idioms ? - 루프 관용구. 즉 루프를 설계할 때 사용하는 패턴이다.

루프를 활용해 몇가지 패턴을 알게 되면 우리는 다양한 작업들을 수행할 수 있게 됩니다.

집합을 이용한 루프 (Looping through a Set)

  print('Before')
  for thing in [9, 41, 13, 3, 74, 15] :
    print(thing)
  print('After')

최대수 구하는 패턴

  변수 -1을 설정해놓고
  for in 반복문을 이용하여 집합에 있는 원소들을
  설정한 변수와 크기를 비교하여 크기가 더 크다면
  설정한 변수에 그 집합 원소를 저장하는 방식의 아이디어
  (하지만 리스트가 음수이면 작동하지 않는다.)

루프에서 개수 구하기 (Counting in a Loop)

  리스트에 몇 개의 원소가 있는지를 알고자 할 때 우리는 루프를 사용할 수 있습니다.

  루프를 몇 번 실행했는지 횟수를 구하기 위해서 print() 함수와
  0에서 시작하는 카운팅 변수를 도입하고 루프를 실행할 때 마다 1을 더함

루프에서 총합 구하기 (Summing in a Loop)

  루프에서 만난 값을 모두 더하기 위해, 0에서 시작하는 합계 변수를 도입하고
  루프를 실행할 때 마다 값을 더함

루프를 사용하여 평균 구하기

  총합 변수(count)와 합계 변수(sum)를 설정하고 (두 값은 모두 0으로 시작)
  반복문에서 리스트를 사용하여 count를 1씩 올려주면서
  sum에는 원래 sum과 리스트의 value의 합을 저장한다.
  루프가 끝났으면 sum/count 로 계산해주면 평균 값을 구할 수 있다.

부울값을 사용하여 특정 값을 검색하기. (루프를 사용하여 필터링 하기)

  전역공간에 부울 변수를 선언하고,
  리스트를 반복문과 조건문을 이용하여 값이 같으면 부울 값을 바꿔준다.

  * 특정 값을 찾았을 때 해당 루프를 종료하는 것이 더욱 적절하다.

최소수 구하는 패턴

  최대수가 같은 패턴으로 하기에는 얼마나 큰 수를 설정해야 할지 모르기 때문에
  설정한 변수의 값을 None으로 해준다.
  즉 집합의 첫번째 수를 포착할 수 있는 루프를 설계해야한다.

  None 자료형은 단 하나의 값만 가지는 특별한 표식이다.
  불리언은 True와 False 두 값을 가지고
  정수, 실수는 무한 개의 값을 가지고
  None 자료형은 상수이다. 단 하나의 값을 가진다. 공백을 나타내기 위해 자주 쓰인다.

  루프 전에 루프 블럭 밖의 전역 공간에 smallest = None 을 선언해주면
  이는 곧 루프가 시작되기 전에는 확인한 숫자 중 최솟값은 없다는 뜻을 의미한다.

  이러한 방식은 최댓값을 구할 때도 유용하게 쓰인다.

* 구현한 코드가 다뤄야할 숫자에 따라 좋은 가정이 아닐 수도 있다.

* is 연산자는 == 보다 강력하다.

-----------------------------------------------------

is

  == 연산자보다 강력하다.
  비교대상 두 개의 자료형과 값이 같은지 물어본다.
  변수의 자료형과 값 둘다 동등한지를 물어본다.
  동등하면 true, 아니면 false를 반환한다.
  (불리언 자료형이나 None 자로형에만 사용하도록 하자.)

  * 자바스크립트, PHP에서 === 와 같음.

is not

  역시 연산자이다.
  is not none, is not false 이런식으로 적으면 된다.


Indefinite vs Definite

  불확실한, 불분명한, 불명확한 vs 명확한

------------------------------------------------------

Indexing strings []

Slicing strings [2:4]

Looping through strings with for and while

Concatenating strings with +

* 인풋 함수는 문자열을 반환한다.
  사용자 입력으로 들어오는 값은 문자열 타입으로 입력되므로
  입력된 값으로 다른 무엇인가를 하기를 원한다면 적절한 타입 변환을 해줘야 한다.

문자열 타입과 관련하여서는 타입 변환, 인덱싱, len 함수, for 루프 활용을 이해하고 사용할 수 있으면 됨.

문자에 대한 인덱스는 0부터 시작한다.

논리연산자로서의 in

  in 키워드는 어떤 문자열이 다른문자열에 "포함" 되는지
  확인하기 위해서도 사용된다.

  in 표현식은 참 또는 거짓 값을 반환하는 논리 표현식이며 if 구문에 사용될 수 있다.

  ex) fruit = 'banana'
      'n' in fruit
      True 반환

문자열 라이브러리

  파이썬은 여러 개의 문자열 함수를 정의하는 문자열 라이브러리가 존재

  * 메소드는 특수한 형태의 함수 호출이다.
    함수에 매개변수로 전달하는 대신 객체 온점 함수 이름을 적는 것으로
    일어나는 함수 호출이다.

    예를들면 len(x)는 객체 지향이 아니다.
    객체 지향 함수라면 X.무언가() 이다.

  문자열 변수와 상수에 내장되어있는 함수
  모든 문자열에 이미 내장되어 있음

  lower() - 함수를 문자열 변수에 붙임으로써 호출
            원본 문자열을 수정하지 않고 새로운 소문자 문자열 반환

  upper() - 새로운 대문자 문자열 반환

  find() - 문자열 탐색. 하위 문자열을 다른 문자열에서 탐색 가능.
           find() 하위 문자열의 첫 번째로 나타내는 위치를 검색
           찾지 못하면 find()는 -1을 반환.

           * 문자열 좌표는 0에서 시작한다는 것에 주의

  replace() - search and replace. 매우 유용하다.
              ex) 문자열에 있는 모든 x를 탐색하고 찾아낸 x를 y로 대체한다.
              이 메소드는 하나 이상의 일을 한다.
              하나를 찾는게 아니라 문자열의 모든 문자를 찾아서 대체한다.

  공백 제거 (종종 문자열의 끝과 마지막에 남아있는 공백을 제거)

    lstrip() - 문자열 왼쪽의 공백을 제거
    rstrip() - 문자열 오른쪽의 공백을 제거
    strip() - 문자열 시작과 끝에 있는 모든 공백을 제거

  Prefixes - 접두사

    startswith() - 시작 문자열 찾기. 결과값은 불리언 타입으로 반환된다.
                   해당 문자열로 시작한다면 True, 그렇지 않다면 False

* 파이썬 3의 큰 특징 중 하나는 모든 내부 문자열이 유니코드라는 것이다.

u 는 유니코드 연산자. 파이썬 2에서는 u 붙이면 아시안 문자들은 유니코드로 인식했다.
사용하기 훨씬 어려웠음. (스페인, 프랑스어도)
파이썬 3부터는 문자 집합을 인식하기 시작했다.

--------------------------------------------------

파일

* 파일이 어떠한 방식으로 열리는 이해하고 파일을 열기 위한 open() 함수를 사용할 수 있다.
  open 함수는 파일을 읽기 가능하게 해준다.

open() 사용

사용법

  핸들 = open(파일명,모드)

  파일을 조작하는데 쓰는 핸들을 반환함

  파일명에는 문자열이 들어감

  모드에 매개 변수를 넣는 것은 선택 사항이며 파일을 읽으려면 'r'을, 파일에 쓰려면
  'w'를 입력

* 핸들은 파일에 접근할 수 있게 도와준다.
  파일 자체도 아니고 데이터도 아니다. 단지 파일에 접근하는 창구일 뿐이다.

개행 문자

  \n 은 다른 문자와 같이 하나의 문자이다.

  각 줄이 끝날 때 이를 알리기 위해 "개행 문자"라고 부르는 특수한 문자를 사용한다.

    * 개행 문자는 한글자이다. 두 글자가 아님.

  줄바꿈을 의미한다.

  텍스트 파일은 각 줄 끝에 개행 문자가 있다. 눈에 보이지 않을 뿐.(엔터키 입력시)

  개행 문자는 그 자체로 문자임을 알아야 한다!

    * 우리는 모든 줄이 개행 문자로 끝난다는 것을 인지하고 있어야 한다!

파일을 읽는 일반적인 방법?

순차적으로 파일 다루기(File Handle as a Sequence)

  파일을 여러 줄의 문장으로 보고 for 루프를 이용하여 (순차적으로) 파일을 읽는 것이다.

  ex)
      xfile = open('mbox.txt')
      for cheese in xfile:
        print(cheese)

  C나 C++ 등의 다른 프로그래밍 언어는 while 루프에서 파일이 끝나는 조건도 적어줘야 해서
  이런 반복문을 작성하는 것 더 어렵다.
  하지만 파이썬은 멋지고 쉽게 한다.

파일의 줄 수 세기(Counting Lines in a File)

  for문을 이용하여 각 줄을 읽는다.
  줄을 세고 줄의 수를 출력한다.

  fhand = open('mbox.txt')
  count = 0
  for line in fhand:
    count = count + 1
  print('Line Count:', count)

파일 전체 읽기(Reading the *Whole* File)

  핸들로 사용되는 변수 fhand가 있으면
  fhand.read()를 이용하자.

  ex)
      >>> fhand = open('mbox-short.txt')
      >>> inp = fhand.read()
      >>> print(len(inp))
      94626
      >>> print(inp[:20])
      From stephen.marquar

파일 내용 탐색(Searching Through a File) - 전형적인 첫번째 방법

  ex)

    fhand = open('mbox-short.txt')
    for line in fhand:
      line = line.rstrip()
      if line startswith('From:') :
        print(line)

    From: stephen.marquard@uct.ac.za
    From: louis@media.berkeley.edu
    From: zqian@umich.edu

    * 공백은 출력되지 않는 모든 것을 의미한다.
      개행 문자는 출력되지 않는 공백 문자이므로 rstrip으로 지울 수 있다!

continue문으로 넘어가기 (Skipping with continue) - 두번째 방법

  건초 더미에서 바늘 찾는 법?
  모든 내용을 루프에 넣고 우리가 원하는줄을 골라내보자!

  continue 문을 사용하여 편리하게 줄을 넘길 수 있음

  예시)

    fhand = open('mbox-short.txt')
    for line in fhand:
      line = line.rstrip()
      if not line.startswith('From:') :
        continue
      print(line)

  * 관심없는 줄을 생략하고 계속 내려감. 여러 줄을 생략한다.
    선별한 줄로 다음 작업을 진행할 수 있다.

파일 이름 입력 받기

    사용자가 파일의 이름을 직접 입력해야 하는 경우도 있을 수 있습니다.
      ex) fname = input('Enter the file name: ')
          try:
            fhand = open(fname)
          except:
            print('File cannot be opend: ',fname)
            quit()

          나머지 로직
          ...
          .
          .

    파일명을 적절힌 입력한다면 문제가 없겠지만 잘못된 파일명을 입력했을 때
    처리방법을 생각할 필요가 있습니다. 이미 배운 try, except문을 적절히 활용하면
    발생할 수 있는 오류 상황을 적절하게 해결 할 수 있을 것입니다.

* quit()은 특별한 함수로 실행되면 아무것도 반환하지 않는다
  이것이 파이썬 프로그램을 에러 없이 조용하게 끝내는 방법이다.

  오류를 발견하여 작동을 중지할 때 아주 좋은 도구이다.

# File Handle?
# 텍스트 파일을 읽는 하나의 표준화된 형태
# 순차적으로 텍스트 파일을 읽는다.

---------------------------------------------------------

컬렉션이란?

  하나의 변수에 여러 값을 넣는 것이 가능하도록 하는 것을 컬렉션이라고 한다.

  리스트, 딕셔너리, 튜플 등이 있다.


리스트

  필요에 따라 하나의 변수에 많은 데이터를 넣을 수도 있다.
  이를 리스트라고 한다.

문자열은 변경이 불가능하다.

  문자열은 fruit[0] = 'b' 이런 방식으로
  문자열의 내용을 변경할 수 없다.
  즉 인덱스 연산자를 사용하여 문자열의 요소 변경이 불가능하다.
  변경하려면 내장함수등을 사용하여 새 문자열을 만들어야한다.

  ex) x = fruit.lower()

리스트는 변경이 가능하다.

  인덱스 연산자를 사용하여 리스트의 요소 변경이 가능하다.

  ex) >>> lotto = [2, 14, 26, 41, 63]
      >>> lotto[2] = 28
      >>> print(lotto)
      [2, 14, 28, 41, 63]

len() 함수

  아무 집합이나 시퀀스(예) 문자열)를 받아 원소의 개수를 반환한다.

  문자열안의 문자 개수를 세어주거나, 리스트의 경우 리스트 안의 원소 개수를 알려준다.

  * len 함수는 원소의 개수가 몇 개인지 알려준다

range() 함수

  range() 함수는 인자로 전달되는 값에 따라서 숫자로 이루어진 리스트를 반환한다.

  * 0부터 매개 변수로 넣은 값보다 1 작은 범위의 수까지로 구성된 숫자 리스트를 반환

  ex) >>> print(range(4))
      [0, 1, 2, 3]
      >>> friends = ['Joseph', 'Glenn', 'Sally']
      >>> print(len(friends))
      3
      >>> print(range(len(friends)))
      [0, 1, 2]

range() 와 len() 을 이용한 두가지 루프

  friends = ['Joseph', 'Glenn', 'Sally']

  for friend in friends :
    print('Happy New Year:', friend)

  for i in range(len(friends)) :
    friend = friends[i]
    print('Happy New Year:', friend)

파이썬은 연산자에 의해 객체 지향적 접근법으로 다가간다.

Concatenating lists using +

  + 연산자를 사용하여 존재하는 두 리스트들을 하나의 새로운 리스트로 합칠 수 있다.

Lists can be sliced using :

  리스트도 :(콜론)을 이용해 자를 수가 있습니다.
  여기서 중요한 것은 예를 들어 t[1:3]과 같은 경우
  3번째 인덱스에 해당하는 항목은 포함되지 않는다는 것입니다.

  예시)
  >>> t = [9, 41, 12, 3, 74, 15]
  >>> t[1:3]
  [41,12]
  >>> t[:4]
  [9, 41, 12, 3]
  >>> t[3:]
  [3, 74, 15]
  >>> t[:]
  [9, 41, 12, 3, 74, 15]

  * 문자열과 마찬가지로, 괄호 안의 두 번째 숫자 "직전"까지(미만)만 포함한다.

리스트 원소 탐색

  >>> some = [1, 9, 21, 10, 16]
  >>> 9 in some
  True
  >>> 15 in some
  False
  >>> 20 not in some
  True

  위 코드 처럼 in 과 not in 을 이용하여 특정 원소가 리스트에 있는지 확인이 가능하다.

dir() 메소드

  특정 타입에서 사용할 수 있는 메소드의 목록들을 볼 수 있는 함수도 있습니다.
  ex)
    x = list()
    print(dir(x))

List Methods

  리스트를 잘 조작하기위해 내장된 함수(메소드) 들이 많다.

  count는 리스트 요소가 몇 개 들어있는지 알려준다.
  extend는 리스트 끝에 원소를 추가해준다.
  index는 리스트의 특정 원소를 찾아 위치 값을 반환한다.
  insert는 리스트 중간에 요소를 삽입하여 리스트가 확장될 수 있도록 한다.
  pop은 리스트에서 마지막 원소를 꺼내고
  remove는 특정 원소를 삭제하고
  reverse는 리스트 내 원소 배열 순서를 뒤집으며
  sort는 값에 따라 원소를 정렬한다.
  append 메서드를 이용하여 빈 리스트에 요소들을 추가할 수 있다.
    ex)
      >>> stuff = list()
      >>> stuff.append('book')
      >>> stuff.append(99)
      ['book', 99]
      >>> stuff.append('cookie')
      >>> print(stuff)
      ['book', 99, 'cookie']

from Scratch? - 처음부터. (경마경기 선 그은데부터 출발한다는 데에서 유래한 영어 숙어

hou = list() ?

  파이썬에게 빈 리스트를 만들고 빈 리스트를 할당하라는 생성자 형태의 문법이다.
  리스트이긴 하지만 변수 hou에 할당된 빈 리스트이다.


Best friends: Strings and Lists - 문자열과 리스트는 잘 어울려 사용된다.

  split() 메소드

    빈 공간, 공백을 기준으로 문자열을 작게 나누고 나뉜 문자열로 구성된 리스트를 생성한다.
    이 문자열은 단어로 볼 수 있다.

    * 인덱스를 이용하여 특정 단어에 접근하거나 모든 단어에 대해 루프를 실행할 수 있다.

    탭이나 줄 바꿈, 또는 다른 문자에 대해서도 분할이 가능하다.
    split 메소드의 인자에 원하는 문자열을 입력하면 된다.

    * 명시적으로 구분자를 넣어주지 않으면, 빈칸을 구분자로 인지하고 나누게 됩니다.

Guardian Pattern - 위험한 코드로부터 에러가 날 수 있음을 방지해준다.

[Algorithm]Short circuit evaluation - 최단평가

  Short Circuit Evaluation이란 AND 혹은 OR의 연산에 있어서
  결과가 확실하게 예측이 되었을 때 뒤에 나머지 연산을 실행하지 않고
  답을 내버리는 경우를 의미합니다.

  AND 연산의 경우

    AND연산의 경우에 false가 우선 나와버리면 AND 뒤에 나오는 연산은 생략이됩니다.

  OR 연산의 경우

    OR연산의 경우에 true가 우선 나와버리면 OR 뒤에 나오는 연산은 생략이됩니다.

-----------------------------------------------------

리스트

  순서대로 정리된 컬렉션이다. 데이터를 추가하면 항상 리스트의 끝에 추가되고 0부터 n-1번 위치까지
  순서대로 n개의 원소가 저장되어 있다.

딕셔너리(Dictionary)

  리스트와 달리 순서라는 것이 없다.
  대신 키(Key)라는 것이 존재한다.
  마치 물건에 포스트잇으로 라벨을 붙이는 것과 비슷하다.
  딕셔너리는 dict()라는 생성자를 통해 생성할 수 있다.
  변수 = {}로 역시 빈 딕셔너리를 만들어 줄 수도 있다
  키는 같은 이름으로 중복이 불가능하다. (값은 같아도 됨)

  * 이렇게 키와 값이 연결되는 개념을 보통 연관 배열이라고 한다.
    접근하는 방식은 리스트와 비슷하나, 키를 가지고 접근한다는 차이점이 있다.

    PHP / Perl 에서는 property maps
    Java에서는 hash maps
    C# / .Net 에서는 property bags 라고 한다.

-----------------------------------------------------

딕셔너리를 활용하여 데이터의 빈도수를 측정할 수 있다.

딕셔너리의 일반적인 활용법 - 히스토그램

  히스토그램이란? 데이터의 빈도를 나타내는 그래프이다.
  히스토그램은 빈도 수를 세는 프로그램이다.

    - 셀 때마다 해당되는 키의 값에 1씩 더해주는 방식.

딕셔너리에 없는 키를 찾으려고하면 오류가 발생하게 됩니다.

  딕셔너리에 in 연산자를 사용함으로써  Traceback 에러를 피할 수 있다.
  (찾으려는 키가 없다면 에러가 나지만, in으로 포함관계인지 알아본다면 false 리턴한다.)

  ex)

    counts = dict()
    names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']
    for name in names :
      if name not in counts:
        counts[name] = 1
      else :
        counts[name] = counts[name] + 1
    print(counts)

    # {'csev': 2, 'zqian': 1, 'cwen': 2}

get 메소드 (딕셔너리 관련 함수)

  * 코드를 간결하게 만들 수 있으므로 get() 메소드를 꼭 기억하자

  get(x) 함수는 x라는 key에 대응되는 value를 돌려준다.
  즉 Key로 Value얻기.

  두번째 매개변수는 키에 대응되는 값이 없을시 설정되는 기본값을 의미.

  이와 같이 딕셔너리에 존재하는 키인지 아닌지 여부에 따라 처리하는 패턴은
  get이라는 메소드를 사용해서 간결하게 해결할 수 있습니다.
  여기에서 counts.get(name, 0)의 의미는 counts 딕셔너리에 name이라는 키가
  존재할 경우 name에 대한 값을 불러오고, 그렇지 않을 경우에는 counts 딕셔너리에
  name이라는 키에 0이라는 값을 갖는 데이터(default)를 추가하라는 의미입니다.

  ex)

    counts = dict()
    names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']
    for name in names :
      counts[name] = counts.get(name, 0) + 1
    print(counts)

    # {'csev': 2, 'zqian': 1, 'cwen': 2}

    키가 아직 딕셔너리에 업으면 get을 사용하여 기본값으로 0을 줄 수 있음.
    그리고 1을 더함.

    앞으로는 이런 패턴을 자주 보실 것입니다.

딕셔너리에는 저장되는 순서가 없다고 해도, for 문을 작성하여
딕셔너리의 모든 원소를 돌 수 있습니다.

  - 딕셔너리의 모든 키를 거쳐가며 값을 찾는다.

items() 메소드

  Key, Value 쌍 얻기(items)
  두개의 반복 변수를 사용하여 딕셔너리의
  키-값 쌍을 반복해서 다룰 수 있다.

      jjj = { 'chuck' : 1 , 'fred' : 42, 'jan': 100}
  ex) for aaa,bbb in jjj.items() :
          print(aaa, bbb)
  키와 값의 쌍으로 된 리스트를 반환한다.

* 딕셔너리는 컬렉션 중 가장 강력하다.
  컬렉션이 무엇인지 이해하기 위해 리스트와 딕셔너리를 보는게 좋음.
  하나 이상의 대상 자기 내부에 포함하여 다룰 수 있게 하는 파이썬의
  도구이기 때문.

clear() 메소드

  Key: Value 쌍 모두 지우기

  clear() 함수는 딕셔너리 안의 모든 요소를 삭제한다.
  빈 리스트를 [ ], 빈 튜플을 ()로 표현하는 것과 마찬가지로 빈 딕셔너리도 { }로 표현한다.

keys() 메소드

  Key 리스트 만들기

  ex)
    >>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
    >>> a.keys()
    dict_keys(['name', 'phone', 'birth'])

values() 메소드

  Value 리스트 만들기

  ex)
    >>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
    >>> a.values()
    dict_values(['pey', '0119993323', '1118'])

---------------------------------------------

튜플(Tuple)

  Tuple are like lists.
  but... Tuples are "immutable"

  리스트는 바뀔 수 있지만 튜플은 바뀔 수 없다. 아이템 할당이 안됨 ( ex) x[2] )
  리스트와 기능은 거의 같지만 리스트와는 다르게 소괄호를 사용한다.

  * 딕셔너리는 {}, 리스트는 [], 튜플은 ()

  튜플은 한번 할당이 되면 바꿀 수 없다.
  왜 이렇느냐? 바로 효율성 때문이다.
  용량도 적게 차지하고, 접근도 빠르고, 리스트보다 효율적이다.
  그냥 값을 저장하고 접근만 할거라면 리스트보다 튜플이 낫다.
  리스트는 sort() 메소드가 되지만 튜플은 불가능하다.
  리스트 append()나 reverse()등 변경하는 작업들은 전부 튜플에서 불가능하다.

  t = tuple()
  dir(t)
  해보면 count랑 index 메소드는 사용 가능한 것을 알 수 있다.

  즉 튜플은 제한이 있는 리스트이다. 왜 사용할까? 더 효율적이기 때문.
  보다 효율적으로 메모리를 활용 가능

튜플을 사용하기 좋을 때?

  임시로 사용하는 변수를 만들 때이다.
  어차피 임시로 사용하고 버리는 변수이니 간단하고 깔끔하게 사용이 가능하다.

  리스트는 보다 다양한 것을 구축하는데 쓰인다.

좌변에 변수를 가진 채로 선언할 수 있다.


여러 값에 대해 비교 가능

  튜플의 또다른 장점은 여러 값에 대해 비교가 가능하다는 점입니다.

  비교의 방법은 각 튜플의 가장 왼쪽 값끼리 비교한 후 둘의 값이 다를 경우에는
  나머지 값들을 비교하지 않고 큰지 작은지 여부를 판단합니다.

  만약 가장 왼쪽 값이 동일할 경우에는 그 다음 값을 비교하고,
  그 값도 같으면 또 다음 값을 비교하는 형태로 비교가 진행됩니다.

  같으면 패스하고 맞으면 true 반환.

* 딕셔너리에서 items() 메소드는 튜플로 된 리스트를 반환한다.

  for문과 함께 사용할 때?

    c = {'a':10, 'b':1, 'c':22}
    for k, v in c.items() :
      ...

    여기서 k, v는 (k,v) 인 튜플이고, 소괄호는 생략할 수도 있다.

* sorted() 메소드는 시퀀스를 인자로 받아 키를 기준으로 정렬시키고 정렬된 시퀀스를 리턴한다.

    예)
        >>> d = {'a':10, 'b':1, 'c':22}
        >>> t = sorted(d.items())
        >>> t
        [('a', 10), ('b', 1), ('c', 22)]
        >>> for k, v in sorted(d.items()):
        ...    print(k, v)
        ...
        a 10
        b 1
        c 22

튜플, 리스트, 딕셔너리를 이용해서 값을 오름차순으로 정렬(쉽게 쓴 버젼)

        c = {'a':10, 'b':1, 'c':22}
        print( sorted( [ (v,k) for k,v in c.items() ] ) )
        # [(1, 'b'), (10, 'a'), (22, 'c')]

        파이썬에서 []는 리스트임을 의미한다.
        (v,k)라고 써준 것은 리스트가 튜플인 것을 의미한다.
        append 함수를 써주지 않아도 고오급 언어인 파이썬에서
        for 반복문을 사용하여 튜플을 리스트에 차곡차곡 넣어줄 수 있음.

        값을 기준으로 정렬해주고 (sorted()메소드 사용)
        정렬된 후에는 키와 값의 쌍으로 출력할 수도 있다.

파싱이란?

  어떤 data를 원하는 form으로 만들어 내는 것
  데이터를 원하는 형태 또는 양식으로 만들어 내는 것입니다.

----------------------------------------------------

영어상식 - Fine-tuning은 미세조정 이라는 뜻이다.
          handout - 유인물 (수업이나 회의에 참석한 사람에게 전달되는 정보가 적힌 종이)
          print - 인쇄, 신문, 압박

Regular Expressions(정규 표현식)


^ Matches the beginning of a line
$ Matches the end of the line
. Match any character
\s Matches whitespace
\S Match any non-whitespace character
* Repeats a character zero or more times
*? Repeats a character zero or more times (non-greedy)
+ Repeats a character one or more times
*? Repeats a character one or more times (non-greedy)
[aeiou] Matches a single character in the listed set
[^XYZ] Matches a single character not in the listed set
[a-z0-9] The set of characters can include a range

: 는 특수문자가 아니라 그냥 문자이다.
[] 는 문자 하나를 나타낸다. 대신 괄호 안 조건에 포함되는 문자여야 한다.

  [^ ]는 \S 와 같다. 공백이 아닌 모든 문자를 의미한다.

() 는 정규식에 포함되지 않는다. 추출 시작점과 끝점을 지정해주는 역할만 한다.
   괄호를 사용하면 정규표현식이 좀 더 정교해진다.

   매칭에 비포함되며 추출될 문자열의 시작과 끝 지점을 지정해주면 된다.


정규표현식은 문자열 비교나 처리를 하기 위한 아주 똑똑한 와일드 카드 표현식이다.
정규 표현식을 파이썬과 함께 사용하려면 import re 로 정규식 라이브러리를 가져와야 한다.

관련 메소드

  re.search() 매개 변수를 받아 문자열 내에서 검색하는 함수

    re.search() 메소드는 정규표현식과 매치되는 문자열이 있으면
    True를 리턴하고, 아닐경우 False를 리턴한다.

    예 )
        아래는 정규표현식라이브러리를 불러와 (import re)
        사용한 함수지향적 코드.

          * 여기서 line은 매개변수

          if re.search('From:', line):
            print(line)

            * find가 하는 일을 정규식을 이용해서 한것이다.

        아래는 객체지향적인 코드

          if line find('From:') >= 0:
            print(line)

    if line.startswith('From'): 은 정규표현식을 사용한 아래 코드와 같다.
    if re.search('^From:', line):

      차이점은 문자열과 관련된 내장 메소드(일반 함수)를 썼느냐,
      아니면 정규 표현을 사용했느냐 이다.

  * 문자열 함수를 전부 합쳐도 정규식으로 할 수 있는 것보다
    기능이 제한되어있기 때문에 정규식을 사용하면 더욱 효과적이다!

  re.findall() 문자열을 쭉 순회하면서 정해진 패턴을 만족하면 추출하는 함수

    re.findall() 을 사용하면 정규식에 매칭되는 부분 문자열을 모은 *리스트*를 리턴한다.
    첫번째 매개변수는 패턴(문자열로 입력한다.), 두번째 매개변수는 메소드를 적용할 변수를 의미한다.

    예)
        >>> import re
        >>> x = 'My 2 favorite numbers are 19 and 42'
        >>> y = re.findall('[0-9]+',x)
        >>> print(y)
        ['2', '19', '42']
        >>> y = re.findall('[AEIOU]+',x)
        >>> print(y) # 조건에 만족하는 부분이 없으므로 빈 리스트를 리턴할 것이다.
        []

        * 만족하지 않으면 아이템이 없는 빈 리스트를 리턴하므로
          제대로 작동하는지 수동으로 꼭 체크해봐야한다.

* 정규표현식 라이브러리를 사용하여 문자열에서 데이터를 추출할 수 있다!

수량자는 일반적으로 탐욕적인 방식이다. 최대한 길게 더 찾으려고 한다.
수량자 뒤에 ? 문자를 추가하여 Non-Greedy Matching을 사용할 수 있다.(게으른 수량자)

대부분은 그렇지 않지만 정규표현식에서는 탐욕적인게 기본이고 탐욕적이지 않은 것은 선택사항임.
정규식은 욕심쟁이! 그렇지만 짧게도 가능하다.

repeat characters 인 *와 +는 가장 길게 매칭되는 경우를 검색한다.
?를 붙여주면 욕심을 버릴 수 있음. ?를 붙이면 가장 짧은 경우를 검색할 수 있다.

이메일 찾을 때 패턴

  \S+@\S+ ( 공백이 아닌문자 하나이상 여러개,사이는 @, 공백이 아닌문자 하나이상 여러개 )
  탐욕적으로 작동.

패턴 추출 및 최댓값 찾기

  지금까지 배운 내용들을 종합하면 텍스트 파일에서 특정 패턴을 찾고,
  그 패턴들 중 가장 큰 값이 어떤 것인지 찾을 수 있다.

  import re
  hand = open('mbox-short.txt')
  numlist = list()
  for line in hand:
      line = line.rstrip()
      stuff = re.findall('^X-DSPAM-Confidence: ([0-9.]+)', line)
      if len(stuff) != 1 :  continue
      num = float(stuff[0])
      numlist.append(num)
  print('Maximum:', max(numlist))


예외 문자(Escape Character)

  특수 문자로 이루어진 패턴을 찾으려면 어떻게 해야 할까?

  역슬래시(\)를 사용하면 된다.

  예를 들어, '$' 문자가 포함된 패턴을 찾고 싶을 때는 다음과 같이 코드를 작성할 수 있다.

  import re
  x = 'We just received $10.00 for cookies.'
  y = re.findall('\$[0-9.]+',x)
  print(y)

  # ['$10.00']

*정규표현식에서는 ()로 추출할 부분을 지정할 수 있다! 이것을 기억하면 더 섬세한 추출이 가능해진다!!
